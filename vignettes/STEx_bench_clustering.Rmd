---
title: "Comparing STExplorer's FGWC and other clustering mehtods"
author: 
  - name: "Eleftherios Zormpas"
    affiliation:
    - "Biosciences Institute, Faculty of Medical Sciences, Newcastle University, UK"
    email: e.zormpas2@ncl.ac.uk, zormpaslef@outlook.com
  - name: "Simon J Cockell"
    affiliation:
      - "School of Biomedical, Nutritional and Sport Sciences, Newcastle University, UK"
    email: simon.cockell@newcastle.ac.uk
# package: STExplorerDev
output: 
  BiocStyle::html_document:
    toc_float: true
bibliography: [references.bib]
vignette: >
  %\VignetteIndexEntry{STExplorer}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", eval = FALSE
)
```

# Introduction

Welcome to the vignette of STExplorer. STExplorer is a package the performs geographically inspired analysis of spatial transcriptomics data.

In this vignette we are benchmarking 

## Install/Load packages

```{r }
## To install the stable version of the package from Bioconductor run the below:
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("STExplorer")


## To install the development version of the package form GitHub run the below:
if (!require("devtools", quietly = TRUE))
    install.packages("devtools")

devtools::install_github("LefterisZ/STExplorer",
                         auth_token = AUTH_TOKEN,
                         force = TRUE)


## To load the package use:
library(STExplorer)
```

```{r setup, echo=FALSE, eval=FALSE, message=FALSE}
library(readr)
# library(SpatialFeatureExperiment)
# library(tidyverse)
# library(scran)
# library(scater)
# library(ggspavis)
# library(sf)
# library(spdep)
# library(GWmodel)
# library(tidyterra)
# library(ggplot2)
# library(igraph)
# library(pheatmap)
# library(ggExtra)
# library(future)
# library(doFuture)
library(foreach)
# library(progressr)
library(parallel)
library(doParallel)
# library(cols4all)
# library(pheatmap)
library(RColorBrewer)
```


## Analysis: Seurat

```{r seurat-load}
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
```

```{r }
rotate_image <- function(p, rot_angle) {
    gt <- ggplot2::ggplot_gtable(ggplot2::ggplot_build(p))
    panel_idx <- which(gt$layout$name == "panel")
    rot_vp <- grid::viewport(angle = rot_angle)
    gt[["grobs"]][[panel_idx]] <- grid::editGrob(gt[["grobs"]][[panel_idx]], vp = rot_vp)
    p_rot <- cowplot::ggdraw() + cowplot::draw_grob(gt)

    return(p_rot)
}
```

### Load data
```{r }
seu <- Load10X_Spatial(data.dir = "../data/test_data/Visium_Human_Prostate/Patient1/V1_2/outs")
```

### QC
```{r }
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "^MT-")

# Visualize QC metrics as a violin plot
plot1 <- VlnPlot(seu, features = "nCount_Spatial", pt.size = 0.1) + NoLegend()

# Visualize QC metrics as a map
plot2 <- SpatialFeaturePlot(seu, features = "nCount_Spatial") + theme(legend.position = "right")

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated seu the object, i.e. columns in object metadata, PC scores etc.
plot3 <- FeatureScatter(seu, feature1 = "nCount_Spatial", feature2 = "percent.mt")
plot4 <- FeatureScatter(seu, feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial")

# Plot
plot1
plot2
plot3
plot4

wrap_plots(plot1, plot2, plot3, plot4)
```

```{r }
seu <- subset(seu, subset = nFeature_Spatial > 500 & nFeature_Spatial < 8000 & percent.mt < 20)
```

### Normalise Counts

Keep this vignette in mind: https://satijalab.org/seurat/articles/sctransform_vignette

```{r }
seu <- SCTransform(seu, assay = "Spatial", verbose = FALSE)
```

```{r }
# Plot gene expression
SpatialFeaturePlot(seu, features = c("LTF", "MSMB"))
p1 <- SpatialFeaturePlot(seu, features = "LTF", pt.size.factor = 1)
p2 <- SpatialFeaturePlot(seu, features = "MSMB", alpha = c(0.1, 1))
p1 + p2
```

### Find HVGs
```{r }
seu <- FindVariableFeatures(seu, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(seu), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(seu)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1
plot2
```
### Reduce Dimensions
```{r }
seu <- RunPCA(seu, assay = "SCT", verbose = FALSE)
seu <- FindNeighbors(seu, reduction = "pca", dims = 1:30)
```

### Cluster
```{r }
seu <- FindClusters(seu, verbose = FALSE, resolution = 0.8)
```

### Add UMAP
```{r }
seu <- RunUMAP(seu, reduction = "pca", dims = 1:30)
```

```{r }
p1 <- DimPlot(seu, reduction = "umap", label = TRUE) + scale_colour_manual(values = STExplorer::getColours(12))
p2 <- SpatialDimPlot(seu, label = FALSE, image.alpha = 0) + scale_fill_manual(values = STExplorer::getColours(12)) + coord_flip()
p2 <- rotate_image(p2, 270)
p1
p2
p1 + p2
```

```{r }
SpatialDimPlot(seu, cells.highlight = CellsByIdentities(object = seu), facet.highlight = TRUE, ncol = 5)
```

### Find Markers
```{r }
de_markers <- FindMarkers(seu, ident.1 = 5, ident.2 = 6)
SpatialFeaturePlot(object = seu, features = rownames(de_markers)[1:3], alpha = c(0.1, 1), ncol = 3)
```
### All-in-one: no plots
```{r }
# Seurat analysis without plots

# 1 Load data
seu <- Load10X_Spatial(data.dir = "../data/test_data/Visium_Human_Prostate/Patient1/V1_2/outs")

# 2 The [[ operator can add columns to object metadata. This is a great place to stash QC stats
seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "^MT-")

# # Visualize QC metrics
# VlnPlot(seu, features = "nCount_Spatial", pt.size = 0.1) + NoLegend()
# SpatialFeaturePlot(seu, features = "nCount_Spatial") + theme(legend.position = "right")
# FeatureScatter(seu, feature1 = "nCount_Spatial", feature2 = "percent.mt")
# FeatureScatter(seu, feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial")

# 3 QC
seu <- subset(seu, subset = nFeature_Spatial > 500 & nFeature_Spatial < 4500 & percent.mt < 20)

# 4 Normalise counts
seu <- SCTransform(seu, assay = "Spatial", verbose = FALSE)
# SpatialFeaturePlot(seu, features = c("LTF", "MSMB"))

# 5 Find HVGs
seu <- FindVariableFeatures(seu, selection.method = "vst", nfeatures = 2000)
# plot1 <- VariableFeaturePlot(seu)
# plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
# plot1
# plot2

# 6 Reduce Dimensions
seu <- RunPCA(seu, assay = "SCT", verbose = FALSE)
seu <- FindNeighbors(seu, reduction = "pca", dims = 1:30)

# 7 Cluster
seu <- FindClusters(seu, verbose = FALSE)
# p1 <- DimPlot(seu, reduction = "umap", label = TRUE)
# p2 <- SpatialDimPlot(seu, label = TRUE, label.size = 3)
# p1 + p2
# SpatialDimPlot(seu, cells.highlight = CellsByIdentities(object = seu), facet.highlight = TRUE, ncol = 3)

# 8 Add UMAP for visualisation
seu <- RunUMAP(seu, reduction = "pca", dims = 1:30)

# 9 Find marker genes
de_markers <- FindMarkers(seu, ident.1 = 5, ident.2 = 6)
# SpatialFeaturePlot(object = seu, features = rownames(de_markers)[1:3], alpha = c(0.1, 1), ncol = 3)
```


## Analysis: scran
```{r stexplorer-load}
library(STExplorer)
library(SummarizedExperiment)
library(foreach)
library(doParallel)
```

```{r }
seurat_to_spe <- function(seu, sample_id, img_id) {
  ## Convert to SCE
  sce <- Seurat::as.SingleCellExperiment(seu)
  
  ## Extract spatial coordinates
  spatialCoords <- as.matrix(
    seu@images[[img_id]]@coordinates[, c("imagecol", "imagerow")])

  ## Extract and process image data
  img <- SpatialExperiment::SpatialImage(
    x = as.raster(seu@images[[img_id]]@image))

  imgData <- DataFrame(
    sample_id = sample_id,
    image_id = img_id,
    data = I(list(img)),
    scaleFactor = seu@images[[img_id]]@scale.factors$lowres)

  # Convert to SpatialExperiment
  spe <- SpatialExperiment::SpatialExperiment(
    assays = SummarizedExperiment::assays(sce),
    rowData = rowData(sce),
    colData = colData(sce),
    metadata = metadata(sce),
    reducedDims = SingleCellExperiment::reducedDims(sce),
    altExps = SingleCellExperiment::altExps(sce),
    sample_id = sample_id,
    spatialCoords = spatialCoords,
    imgData = imgData
  )
  
  # indicate all spots are on the tissue
  spe$in_tissue <- 1
  spe$sample_id <- sample_id
  # Return Spatial Experiment object
  spe
}
```

#### Seurat to SPE
```{r }
spe <- seurat_to_spe(seu = seu, sample_id = "V1_2", img_id = "slice1")
top_hvgs_seu <- seu@assays[["SCT"]]@var.features
```

### SPE to SFE
```{r }
sfe <- toSpatialFeatureExperiment(spe)

dir <- file.path("./data/test_data/Visium_Human_Prostate/Patient1", "V1_2")
names(dir) <- "V1_2"
dir2 <- file.path("./data/test_data/Visium_Human_Prostate/Patient1", "V1_2")
names(dir2) <- "V1_2"

## Fix sfe to make it usable
colnames(spatialCoords(sfe))[colnames(spatialCoords(sfe)) == "imagerow"] <- "pxl_row_in_fullres"
colnames(spatialCoords(sfe))[colnames(spatialCoords(sfe)) == "imagecol"] <- "pxl_col_in_fullres"

data <- read.csv(file.path(dir, "outs/spatial",
                           "tissue_positions_list.csv"),
                 stringsAsFactors = FALSE, header = FALSE)
## Check if for whatever reason there is still column names in the first row
## Check for rows with characters (non-numeric values) in all columns but the
## first
rows_with_characters <- apply(data[, -1], 1,
                              function(row){
                                any(is.na(sapply(row,
                                                 STExplorer:::.int_char_to_numeric)))
                              }
)

## Remove rows with characters (non-numeric values) at any column (but the
## first). We are left with rows that have all columns containing numeric
## values and the first column containing the spot barcodes
data <- data[!rows_with_characters, ]

## Convert all numeric columns (except the first) to numeric
data[, -1] <- lapply(data[, -1], as.numeric)

## Add colnames
colnames(data) <- c("Barcode", "Section", "Spot_Y",
                    "Spot_X", "Image_Y", "Image_X")

## Add gene names as a column
rowData(sfe)[["gene_name"]] <- rownames(sfe)

for (id in "V1_2") {
  message("Working on sample: ", id)
  ## Add location-related statistics
  sfe <- addPerLocQC(sfe, 
                     sample_id = id, 
                     gTruth = NULL, 
                     assay = "counts", 
                     MARGIN = 2)
  message("\tAdded location-related statistics")
  
  # Merge dataframes based on the common column Barcode
  merger <- merge(colData(sfe), 
                  data[,c("Barcode", "Spot_X", "Spot_Y")], 
                  by = "Barcode", 
                  all.x = TRUE) %>% 
    as.data.frame() %>%
    dplyr::arrange(Barcode) %>%
    dplyr::select(c("Barcode", "Spot_X", "Spot_Y"))
  
  colnames(merger)
  identical(merger$Barcode, rownames(colData(sfe)))
  
  colData(sfe)[["array_col"]] <- merger$Spot_X
  colData(sfe)[["array_row"]] <- merger$Spot_Y
  
  ## Add geometries
  sfe <- addGeometries(sfe, 
                       samples = dir, 
                       sample_id = id, 
                       res = "fullres",
                       flipped = FALSE,
                       barcodes = "input")
  message("\tAdded geometries")
  
  ## Add gene/feature-related statistics
  sfe <- addPerGeneQC(sfe, 
                       sample_id = id, 
                       assay = "counts", 
                       version = NULL, 
                       mirror = NULL)
  message("\tAdded gene/feature-related statistics")
}

## Add a neighbour graph using a weighted distance matrix
msfe <- MetaSpatialFeatureExperiment()
msfe <- addSFE(msfe, sfe, "V1_2")

## Add a neighbour graph using a weighted distance matrix
msfe <- addSpatialNeighGraphs(msfe, sample_id = TRUE, type = "knearneigh", style = "W", distMod = "raw", k = 6)

colGraphs(msfe@sfe_data[["V1_2"]])

## Calculate a simple distance matrix
msfe <- addDistMat(msfe, p = 2)

## Check distance matrix was successfully added
msfe@sfe_data[["V1_2"]]@metadata[["dMat"]][["euclidean"]][1:10,1:5]

sfe <- getSFE(msfe, "V1_2")

```

### Reduce dimensions using NMF

> **NOTE:** the number of factors that we get back is left to the default of 2. We suggest that you should play with this number and find the best option for your data. Use the `ncomponents` argument. 

```{r fgwc_nmf}
sfe_nmf_seuIn <- list()

ncompnents <- c(2, 3, 5, 10)

for (ncompnent in ncompnents) {
  name <- paste0("nComp_", ncompnent)
  sfe_nmf_seuIn[[name]] <- fgwc_nmf(sfe, 
                                    sample_id = "V1_2", 
                                    top_hvgs = top_hvgs_seu,
                                    ncomponents = ncompnent,
                                    scale = FALSE)
}
```

### Run FGWC

```{r fgwc_params}
# Parameters
ncluster = c(2,3,4,5) 
a = c(1, 2, 5, 10)
m = c(2, 1.8, 1.5, 1.2)
folder = file.path("./data/graphics_out/benchmarking/FGWC_in-Seurat/clustering/")

# Create all possible combinations
combinations <- expand.grid(ncluster = ncluster, a = a, m = m)

# Set parallel backend
num_cores <- 4
registerDoParallel(cores = num_cores)

foreach(ncomp = 1:length(sfe_nmf_seuIn)) %dopar% {
  message("###################################################\n",
          ncomp, "/", length(sfe_nmf_seuIn), 
          "  Number of NMF factors: ", 
          gsub("nComp_", "", names(sfe_nmf_seuIn)[ncomp]), "\n",
          "###################################################\n")
  
  ncomp <- gsub("nComp_", "", names(sfe_nmf_seuIn)[ncomp])
  
  for (i in 1:nrow(combinations)) {
    # Select parameters
    ncluster = combinations[i,1]
    a = combinations[i,2]
    m = combinations[i,3]
    message(i, "/", nrow(combinations), "  Working on nCl = ", ncluster, ", a = ", a, ", m = ", m)
    # Set FGWC parameters
    fgwc_param <- fgwc_params(algorithm = "classic", ncluster = ncluster, a = a, m = m)
    # Run FGWC
    fgwc <- fgwcSTE(sfe, "V1_2", 
                    data = sfe_nmf, 
                    dMetric = "euclidean", 
                    algorithm = "classic", 
                    parameters = fgwc_param)
    # plot single
    plotFGWC_single(fgwc = fgwc, m_sfe = sfe, sample_id = "V1_2") + 
      theme(legend.position = "none") + 
      labs(title = paste0("nCl:", ncluster, "  a:", a, "  m:", m))
    ggsave(paste0(folder, "V1_2_single_NMF-", ncomp, "_clust-", ncluster, "_a-", a, "_m-", m, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
    # plot multi
    plotFGWC_multi(fgwc = fgwc, m_sfe = sfe, sample_id = "V1_2")+ 
      theme(legend.position = "none")  + 
      labs(title = paste0("nCl:", ncluster, "  a:", a, "  m:", m))
    ggsave(paste0(folder, "V1_2_multi_NMF-", ncomp, "_clust-", ncluster, "_a-", a, "_m-", m, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  }
}
```

## Analysis: STExplorer
```{r stexplorer-load}
library(STExplorer)
library(readr)
library(ggplot2)
```

### Load data
```{r 03_load_sfe, warning=FALSE, message=FALSE}
## Create the MSFE object
msfe <- MetaSpatialFeatureExperiment()

## Prepare vectors with the paths to the data folders
sampleDir <- c("./data/test_data/Visium_Human_Prostate/Patient1/V1_2",
               "./data/test_data/Visium_Human_Prostate/Patient1/H1_4",
               "./data/test_data/Visium_Human_Prostate/Patient1/H1_5")

sampleNames <- c("V1_2", "H1_4", "H1_5")

names(sampleDir) <- sampleNames

## Load sfe objects inside the msfe
for (i in seq_along(sampleNames)) {
  message("Adding sample: ", sampleNames[i])
  msfe <- addSFE(msfe,
               read10xVisiumSFE(samples = sampleDir[i], 
                      sample_id = sampleNames[i], 
                      type = "HDF5", 
                      data = "filtered", 
                      images = "lowres", 
                      style = "W", 
                      zero.policy = TRUE))
}

ground_truth <- read_table("./data/test_data/Visium_Human_Prostate/Patient1/Final_Consensus_Annotations.txt")

gTruth_list <- list(V1_2 = ground_truth[ground_truth$sample_id == "V1_2",],
                    H1_4 = ground_truth[ground_truth$sample_id == "H1_4",],
                    H1_5 = ground_truth[ground_truth$sample_id == "H1_5",])

str(gTruth_list)
```

### Calculating QC metrics
```{r 03_QC_sfe1, message=TRUE, warning=FALSE}
## Mark a subset of mitochondrial genes
is_mito <- getSubset(msfe, 
                     sample_id = TRUE, 
                     subset = "(^MT-)|(^mt-)", 
                     set = "rowData", 
                     col_name = "symbol")

for (id in sampleNames) {
  message("Working on sample: ", id)
  ## Add location-related statistics
  msfe <- addPerLocQC(msfe, 
                      sample_id = id, 
                      gTruth = gTruth_list[[id]], 
                      assay = "counts", 
                      MARGIN = 2, 
                      subsets = list(mito = is_mito[[id]]))
  message("\tAdded location-related statistics")
  
  ## Add geometries
  msfe <- addGeometries(msfe, 
                        samples = sampleDir[id], 
                        sample_id = id, 
                        res = "fullres",
                        flipped = FALSE)
  message("\tAdded geometries")
  
  ## Add gene/feature-related statistics
  msfe <- addPerGeneQC(msfe, 
                       sample_id = id, 
                       assay = "counts", 
                       version = NULL, 
                       mirror = NULL)
  message("\tAdded gene/feature-related statistics")
}
## Keep in-tissue locations
## Use it only if you have loaded "raw" data and not "filtered"
# sfe <- filterInTissue(sfe, sample_id = TRUE)

head(colData(msfe@sfe_data[["V1_2"]]), 4)
head(rowData(msfe@sfe_data[["V1_2"]]), 4)
head(colGeometries(msfe@sfe_data[["V1_2"]]))

## Backup data
msfe_bckup <- msfe
```

### Quality Control: Spots
```{r 03_QC_sfe3, warning=FALSE}
# msfe <- msfe_bckup
sIDs <- c("V1_2", "H1_4", "H1_5")

for (sID in sIDs) {
  message("Working on sample: ", sID)
  sfe <- getSFE(msfe, sID)

  dir.create(paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/annotation/", sID, "/"), recursive = TRUE)  
  dir.create(paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/"), recursive = TRUE)
  dir.create(paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/normalisation/", sID, "/"), recursive = TRUE)
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  plotQC_tissueImg(sfe, res = "lowres", type = "hex", sample_id = sID, annotate = FALSE, alpha = 0.3)
  
  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/annotation/", sID, "/")
  prfx <- sID
  main <- "_TissueWithSpots"
  sfx <- "_annotated"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  plotQC_spotsAnnotation(sfe, type = "hex", sample_id = sID)

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/annotation/", sID, "/")
  prfx <- sID
  main <- "_Spots"
  sfx <- "_annotated"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  ## Density and histogram of library sizes
  p1 <- plotQC_hist(sfe, metric = "libsize", 
              limits = c(500, 
                         quantile(msfe@sfe_data[[sID]]@colData$sum, probs = c(.99))),
              hist_args = list(bins = 100))
  
  ## Map the library sizes
  p2 <- plotQC_map(sfe, metric = "libsize")
  
  p1 + p2

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_LibSize"
  sfx <- "_hist-map"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  ## Select threshold
  sfe <- setQCthresh_LibSize(sfe, sample_id = TRUE, 
                             min_t = 500, 
                             max_t = quantile(msfe@sfe_data[[sID]]@colData$sum, probs = c(.99)))
  
  ## Check putative spatial patterns of removed spots
  plotQC_filtered(sfe, metric = "libsize", sample_id = TRUE)
  

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_LibSize"
  sfx <- "_RemovedSpots"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  ## Density and histogram of expressed genes
  p1 <- plotQC_hist(sfe, metric = "detected", 
                    limits = c(250, quantile(msfe@sfe_data[[sID]]@colData$detected, probs = c(.99))))
  
  ## Map the library sizes
  p2 <- plotQC_map(sfe, metric = "detected")
  
  p1 + p2

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_GeneNumber"
  sfx <- "_hist-map"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  ## Select threshold
  sfe <- setQCthresh_GenesExpr(sfe, sample_id = TRUE, 
                               min_t = 250, 
                               max_t = quantile(msfe@sfe_data[[sID]]@colData$detected, probs = c(.99)))
  
  ## Check putative spatial patterns of removed spots
  plotQC_filtered(sfe, metric = "detected", sample_id = TRUE)

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_GeneNumber"
  sfx <- "_RemovedSpots"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  ## Density and histogram of percentage of mitochondrial expression
  p1 <- plotQC_hist(sfe, metric = "mito", 
              limits = c(NA, quantile(msfe@sfe_data[[sID]]@colData$subsets_mito_percent, probs = c(.99), na.rm = TRUE)),
              hist_args = list(bins = 100))
  
  ## Map the library sizes
  p2 <- plotQC_map(sfe, metric = "mito")
  
  p1 + p2

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_MitoPercent"
  sfx <- "_hist-map"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  ## Select threshold
  sfe <- setQCthresh_Mito(sfe, sample_id = TRUE, 
                          min_t = NA, 
                          max_t = quantile(msfe@sfe_data[[sID]]@colData$subsets_mito_percent, probs = c(.99), na.rm = TRUE))
  
  ## Check putative spatial patterns of removed spots
  plotQC_filtered(sfe, metric = "mito", sample_id = TRUE)

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_MitoPercent"
  sfx <- "_RemovedSpots"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  ## Set the combined filtering threshold using the QC metrics
  sfe <- setQCtoDiscard_loc(sfe, sample_id = TRUE, filters = TRUE)
  
  ## Check putative spatial patterns of removed spots
  plotQC_filtered(sfe, metric = "discard", sample_id = TRUE)

  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/qc/", sID, "/")
  prfx <- sID
  main <- "_QC_All"
  sfx <- "_RemovedSpots"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
           device = "svg",
           width = grDevices::dev.size(units = "in")[1],
           height = grDevices::dev.size(units = "in")[2],
           units = "in",
           dpi = 300)
  
  
  # ---------------------------------------------------------------------------- #
  # ---------------------------------------------------------------------------- #
  ## Remove combined set of low-quality spots
  sfe <- applyQCthresh_loc(sfe, sample_id = TRUE)
  
  dim(sfe)
  
  msfe <- addSFE(msfe, sfe)
}

# Back up the object
# msfe_bckup <- msfe
```

### Normalisation of counts

#### Log-normalisation of counts
```{r 03_LogNorm_sfe}
## Calculate library size factors
msfe <- computeLibSizeFactors(msfe)

for (sID in sampleNames) {
  ## Density and histogram of library sizes
  p1 <- plotQC_sizeFactors(msfe@sfe_data[[sID]])

  ## Map library sizes
  p2 <- plotQC_map(msfe@sfe_data[[sID]], 
                   metric = "custom", 
                   sample_id = sID, 
                   metric_name = "sizeFactor", 
                   metric_lab = "Size factor")
  
  print(p1 + p2)
  
  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/normalisation/", sID, "/")
  prfx <- sID
  main <- "_Normalisation"
  sfx <- "_SizeFactors"
  other <- ""
  
  ggsave(paste0(folder, prfx, main, sfx, other, ".svg"),
         device = "svg",
         width = grDevices::dev.size(units = "in")[1],
         height = grDevices::dev.size(units = "in")[2],
         units = "in",
         dpi = 300)
}

  ## Calculate logcounts using library size factors
  msfe <- normaliseCounts(msfe)

for (sID in sampleNames) {
  ## Check that a new assay has been added
  message("For sample: ", sID)
  print(SummarizedExperiment::assayNames(msfe@sfe_data[[sID]]))
}

# Back up the object
msfe_bckup <- msfe
```

#### Log-transformation of counts
```{r}
## Log2-transform the raw counts but don't correct for library size
for (sID in sIDs) {
  SummarizedExperiment::assay(msfe@sfe_data[[sID]], "unNormLogCounts") <- log2(SummarizedExperiment::assay(msfe@sfe_data[[sID]], "counts") + 1)

  ## Check that a new assay has been added
  message("For sample: ", sID)
  print(SummarizedExperiment::assayNames(msfe@sfe_data[[sID]]))
  
}

# Back up the object
msfe_bckup <- msfe
```

### Quality Control: Genes
```{r 03_GeneQC_sfe1}
## Calculate the mean of log counts over the number of locations a gene is present
msfe <- perGeneLogMean(msfe)

## Zero expression genes
msfe <- setQCthresh_ZeroExpr(msfe)

## Lowly expressed (noise?!) genes
msfe <- setQCthresh_LowLogMean(msfe, threshold = 1)

## Remove mitochondrial and other genes
##    Use it only if you feel it is right for your dataset
msfe <- setQCthresh_custom(msfe, MARGIN = 1, qcMetric = is_mito)

## QC discard Features
## Set the combined filtering threshold using the QC metrics
msfe <- setQCtoDiscard_feat(msfe, filters = TRUE)

## FEATURE SELECTION
## Apply gene-level QC threshold
msfe <- applyQCthresh_feat(msfe)

# Back up the object
msfe_bckup <- msfe
```

### Selecting HVGs
```{r 03_HVGs_sfe}
assay.types <- c("logcounts", "unNormLogCounts")
names(assay.types) <- c("logNorm", "logTransf")

for (assay in assay.types) {
  i <- grep(assay, assay.types)
  
  ## Fit mean-variance relationship
  dec <- modelGeneVariance(msfe, sample_id = TRUE, method = "Var", assay.type = assay)
  
  ## Select top HVGs
  top_hvgs <- getTopHighVarGenes(dec,
                                 var.field = "bio",
                                 prop = 0.1,
                                 var.threshold = 0,
                                 fdr.threshold = 0.1)
  
  ## Visualize mean-variance relationship
  plotGeneVariance(dec = dec, hvgs = top_hvgs)
  
  prfx <- "All"
  main <- "_HVGs"
  sfx <- "_top10_"
  other <- names(assay.types)[i]
  
  ggsave(paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/normalisation/", 
              prfx, main, sfx, other, ".svg"),
         device = "svg",
         width = grDevices::dev.size(units = "in")[1],
         height = grDevices::dev.size(units = "in")[2],
         units = "in",
         dpi = 300)
  
  ## Save to environment
  assign(paste0("top_hvgs_", names(assay.types)[i]), top_hvgs)
}

```

### Neighbour graph and distance matrix
```{r 03_spatial_weights_to_sfe}
## Add a neighbour graph using a weighted distance matrix
msfe <- addSpatialNeighGraphs(msfe, sample_id = TRUE, type = "knearneigh", style = "W", distMod = "raw", k = 6)

for (sID in sampleNames) {
  print(colGraphs(msfe@sfe_data[[sID]]))
}

## Calculate a simple distance matrix
msfe <- addDistMat(msfe, p = 2)

## Check distance matrix was successfully added
for (sID in sampleNames) {
  print(msfe@sfe_data[[sID]]@metadata[["dMat"]][["euclidean"]][1:10,1:5])
}

## Back up data
msfe_bckup <- msfe
```

### FGWC
#### dim-reduction: NMF (logNorm)

> **NOTE:** the number of factors that we get back is left to the default of 2. We suggest that you should play with this number and find the best option for your data. Use the `ncomponents` argument. 

```{r}
## Initialise lists to store results
top_hvgs <- top_hvgs_logNorm # select top HVGs

sfe_nmf_stexIn <- list() # list to store NMF output as is
sfe_nmf_stexIn_basis <- list() # list to export basis table from NMF output's attributes
sfe_nmf_stexIn_scaled <- list() # list to store scaled-NMF output as is
sfe_nmf_stexIn_scores <- list() # list to store location per Factor scores

for (sID in sIDs) {
  i <- grep(sID, sIDs)
  tot <- length(sIDs)
  message("\n################################\n",
          i, "/", tot, "  Working on sample ", sID,
          "\n################################\n")
  
  # Retrieve SFE
  sfe <- getSFE(msfe, sample_id = sID)
  
  ncompnents <- c(2, 3, 5, 10)
  
  for (ncompnent in ncompnents) {
    name <- paste0("nComp_", ncompnent)
    sfe_nmf_stexIn[[sID]][[name]] <- fgwc_nmf(sfe, 
                                              sample_id = sID, 
                                              top_hvgs = top_hvgs[[sID]],
                                              ncomponents = ncompnent,
                                              scale = FALSE)
    
    sfe_nmf_stexIn_basis[[sID]][[name]] <- attr(sfe_nmf_stexIn[[sID]][[name]], "basis")
    attr(sfe_nmf_stexIn[[sID]][[name]], "basis") <- NULL
    
    sfe_nmf_stexIn_scaled[[sID]][[name]] <- scale(t(sfe_nmf_stexIn[[sID]][[name]]), center = TRUE, scale = TRUE) %>% 
      t() %>%
      as.data.frame()
    
    scores <- (sfe_nmf_stexIn[[sID]][[name]]) %>%
    as.data.frame() %>%
    rownames_to_column()
  
    geoms <- colGeometry(sfe, "spotHex") %>%
      rownames_to_column()
    
    # Combine spatial coordinates with scores
    scores <- dplyr::left_join(geoms, scores, by = "rowname") %>%
      column_to_rownames() %>% 
      pivot_longer(cols = -geometry, names_to = "Factors", values_to = "score")
  
    sfe_nmf_stexIn_scores[[sID]][[name]] <- scores
  }
}

```

```{r}
# Visualize spatially informed principal components
ggplot(data = scores) +
  geom_sf(aes(geometry = geometry, fill = score)) +
  facet_wrap(~ Factors) +
  scale_fill_viridis_c() +
  labs(fill = "Factor Score") +
  theme_void()

# Create heatmap of gene loadings
filename <- paste0("./data/graphics_out/benchmarking/dimReduction/nmf_",
                   "Fact", ncomp, 
                   "_scaled", scale,
                   "_geneLoading.png")
heatmap <- pheatmap(sfe_nmf_stexIn_basis$V1_2$nComp_5,
                    scale = "row",
                    cluster_rows = TRUE,
                    cluster_cols = TRUE,
                    fontsize_row = 3,
                    # filename = filename,
                    width = 546,
                    height = 851)

# Create heatmap of PC scores
pheatmap(sfe_nmf,
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_row = 3)

# Perform GSEA analysis of the basis vector

# Initialize a list to store GSEA results for each basis vector
gsea_results_list <- list()

# Generate MSigDB TERM2GENE df
viewCollections()
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP:REACTOME")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP:KEGG")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C5", subcat = "GO:BP")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C7", subcat = "IMMUNESIGDB")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "H", subcat = "")
# t2g <- getTerm2Gene(msig_data = msigdb, cat = "C6", subcat = "")

# Iterate over each basis vector
for (i in 1:ncol(sfe_nmf_basis)) {
  # Rank genes based on their weights within the current basis vector
  ranked_genes <- STExplorer:::.int_sortGenes(sfe_nmf_basis[,i])
  
  # Run GSEA using enricher function
  gsea_results <- clusterProfiler::GSEA(
    geneList = ranked_genes,  # Ranked genes
    TERM2GENE = t2g,  # Gene set collection
    pvalueCutoff = 0.25,  # Set p-value cut-off
    pAdjustMethod = "fdr",  # Adjust p-values for multiple testing
    nPermSimple = 100000 # Adjust perutations
  )
  
  # List name
  name <- paste0("GSEA_", colnames(sfe_nmf_basis)[i])
  
  # Store GSEA results in the list
  gsea_results_list[[name]] <- gsea_results
}

for (i in seq_along(gsea_results_list)) {
  print(gsea_results_list[[i]])
}

# Visualize GSEA results for each basis vector
for (i in seq_along(gsea_results_list)) {
  # Check if results exist
  if (dim(gsea_results_list[[i]]@result)[1] == 0) {
    next
  }
  
  # Visualize GSEA results using dotplot
  print(clusterProfiler::dotplot(gsea_results_list[[i]], 
                           showCategory = 15, 
                           title = paste0("GSEA for Basis Vector NMF", i)))
}

# Perform GSEA analysis of the basis vector per signature
# Extract gene signatures from basis pheatmap
sig_no = 5
signatures <- stats::cutree(heatmap$tree_row, k = sig_no) %>% # cut signatures
  .[heatmap$tree_row$order] %>% # order genes like they were in the heatmap
  as.data.frame() %>%
  dplyr::rename("signature" = ".") %>% 
  dplyr::mutate(signature = as.factor(signature))

# Generate Annotation Colours based on sig_no
ann_colours <- list(
  signature = stats::setNames(getColours(sig_no), 1:sig_no)
)

# Plot the heatmap to visualise the signatures
pheatmap(sfe_nmf_basis,
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_row = 3,
         annotation_row = signatures,
         annotation_colors = ann_colours)

# Move genes to column
signatures <- signatures %>%
  rownames_to_column(var = "gene")

# Initialize a list to store GSEA results for each basis vector
gsea_signatures_list <- list()

viewCollections()

t2g_react <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP:REACTOME")
t2g_kegg <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP:KEGG")
t2g_cPath <- getTerm2Gene(msig_data = msigdb, cat = "C2", subcat = "CP")
t2g_goBP <- getTerm2Gene(msig_data = msigdb, cat = "C5", subcat = "GO:BP")
t2g_immunSig <- getTerm2Gene(msig_data = msigdb, cat = "C7", subcat = "IMMUNESIGDB")
t2g_hallmark <- getTerm2Gene(msig_data = msigdb, cat = "H", subcat = "")
t2g_oncoSig <- getTerm2Gene(msig_data = msigdb, cat = "C6", subcat = "")

# Iterate over each basis vector for each T2G
t2gs <- grep("t2g_.*", names(.GlobalEnv), value = TRUE)

for (t2g in t2gs) {
  message("Now working with ", t2g)
  t2g <- get(t2g)
  
  for (i in 1:ncol(sfe_nmf_basis)) {
    # Rank genes based on their weights within the current basis vector
    genes <- signatures[signatures$signature == i, "gene"]
    
    # Run GSEA using enricher function
    gsea_results <- clusterProfiler::enricher(
      gene = genes,  # Ranked genes
      TERM2GENE = t2g,  # Gene set collection
      pvalueCutoff = 0.05,  # Set p-value cut-off
      pAdjustMethod = "fdr",  # Adjust p-values for multiple testing
      qvalueCutoff = 0.05,  # Set q-value cutoff
      universe = NULL,  # Universe of genes
    )
    
    # List name
    name <- paste0("Signature_", i)
    
    # Store GSEA results in the list
    gsea_signatures_list[[name]] <- gsea_results
  }
  
  # Visualize GSEA results for each basis vector
  for (i in seq_along(gsea_signatures_list)) {
    # Check if results exist
    if (dim(gsea_signatures_list[[i]])[1] == 0) {
      next
    }
  
    # Visualize GSEA results using dotplot
    print(clusterProfiler::dotplot(gsea_signatures_list[[i]], 
                             showCategory = 15, 
                             title = paste0("GSEA for Signature ", i)))
  }
}

```

#### dim-reduction: PCA (logNorm)
```{r}
## Initialise lists to store results
top_hvgs <- top_hvgs_logNorm

sfe_pca_stexIn <- list()
sfe_pca_stexIn_basis <- list()
sfe_pca_stexIn_scaled <- list()
sfe_pca_stexIn_scores <- list()

for (sID in sIDs) {
  i <- grep(sID, sIDs)
  tot <- length(sIDs)
  message("\n################################\n",
          i, "/", tot, "  Working on sample ", sID,
          "\n################################\n")
  
  # Retrieve SFE
  sfe <- getSFE(msfe, sample_id = sID)
  
  ncompnents <- c(2, 3, 5, 10)
  for (ncompnent in ncompnents) {
    name <- paste0("nComp_", ncompnent)
    sfe_pca_stexIn[[sID]][[name]] <- prcomp(t(assay(sfe, "logcounts")[rownames(sfe) %in% top_hvgs[[sID]],]))
    
    scores <- (sfe_pca_stexIn[[sID]][[name]]$x) %>%
      as.data.frame() %>%
      dplyr::select(all_of(paste0("PC", 1:15))) %>%
      rownames_to_column()
    colnames(scores) <- sub("PC([1-9])\\b", "PC0\\1", colnames(scores))
  
    geoms <- colGeometry(sfe, "spotHex") %>%
      rownames_to_column()
    
    # Combine spatial coordinates with scores
    scores <- dplyr::left_join(geoms, scores, by = "rowname") %>%
      column_to_rownames() %>% 
      pivot_longer(cols = -geometry, names_to = "PCs", values_to = "score")
  
    sfe_pca_stexIn_scores[[sID]][[name]] <- scores
  }
  
  
  
}

```

```{r}
# Visualize spatially informed principal components
ggplot(data = scores) +
  geom_sf(aes(geometry = geometry, fill = score)) +
  facet_wrap(~ PCs) +
  scale_fill_viridis_c() +
  labs(fill = "PC Score") +
  theme_void()
```

#### Run FGWC
```{r fgwc_params}
# Parameters
ncluster = c(2, 3, 4, 5) 
a = c(1, 2, 5, 10)
m = c(2, 1.8, 1.5, 1.2)

# Create all possible combinations
combinations <- expand.grid(ncluster = ncluster, a = a, m = m)

# Set parallel backend
# cl <- parallel::makeCluster(6)
# registerDoParallel(cl)

# Run clustering
for (sID in sIDs) {
  i <- grep(sID, sIDs)
  tot <- length(sIDs)
  message("\n################################\n",
          i, "/", tot, "  Working on sample ", sID,
          "\n################################\n")
  
  # Retrieve SFE
  sfe <- getSFE(msfe, sample_id = sID)
  
  dir.create(paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/clustering/", sID, "/"), recursive = TRUE)  
  folder <- paste0("./data/graphics_out/benchmarking/FGWC_in-STExplorer/clustering/", sID, "/")
  
  for (ncomps in 1:length(sfe_nmf_stexIn[[sID]])) {
    ncomp <- gsub("nComp_", "", names(sfe_nmf_seuIn)[ncomps])
    
    data_to_cluster <- sfe_nmf_stexIn[[sID]][[ncomps]]
    
    for (i in 1:nrow(combinations)) {
      # Select parameters
      ncluster = combinations[i,1]
      a = combinations[i,2]
      m = combinations[i,3]
      
      message(i, "/", nrow(combinations), "  Working on nCl = ", ncluster, ", a = ", a, ", m = ", m)
      # Set FGWC parameters
      fgwc_param <- STExplorer::fgwc_params(algorithm = "classic", ncluster = ncluster, a = a, m = m)
      # Run FGWC
      fgwc <- STExplorer::fgwcSTE(sfe, sID, 
                      data = data_to_cluster, 
                      dMetric = "euclidean", 
                      algorithm = "classic", 
                      parameters = fgwc_param)
      # plot single
      STExplorer::plotFGWC_singleMap(fgwc = fgwc, m_sfe = sfe, sample_id = sID) + 
        theme(legend.position = "none") + 
        labs(title = paste0("nCl:", ncluster, "  a:", a, "  m:", m))
      ggsave(paste0(folder, sID, "_single_NMF-", ncomp, "_clust-", ncluster, "_a-", a, "_m-", m, ".svg"),
             device = "svg",
             width = grDevices::dev.size(units = "in")[1],
             height = grDevices::dev.size(units = "in")[2],
             units = "in",
             dpi = 300)
      # plot multi
      STExplorer::plotFGWC_multiMap(fgwc = fgwc, m_sfe = sfe, sample_id = sID) + 
        theme(legend.position = "none")  + 
        labs(title = paste0("nCl:", ncluster, "  a:", a, "  m:", m))
      ggsave(paste0(folder, sID, "_multi_NMF-", ncomp, "_clust-", ncluster, "_a-", a, "_m-", m, ".svg"),
             device = "svg",
             width = grDevices::dev.size(units = "in")[1],
             height = grDevices::dev.size(units = "in")[2],
             units = "in",
             dpi = 300)
    }
  }
}


```

#### FGWC: with logcounts
```{r}
sID <- "V1_2"
n_components <- 10

SummarizedExperiment::assay(sfe, "unNormLogCounts") <- log2(SummarizedExperiment::assay(sfe, "counts") + 1)

sfe_logcnt <- t(SummarizedExperiment::assay(sfe, "unNormLogCounts")[rownames(sfe) %in% top_hvgs[[sID]],])

sfe_logcnt_pca <- prcomp(sfe_logcnt,
                         center = TRUE,
                         scale. = FALSE,
                         retx = TRUE,
                         rank. = min(n_components, ncol(sfe_logcnt)))

fgwc_param <- fgwc_params(algorithm = "classic", ncluster = 4, a = 5, m = 1.5)

fgwc <- fgwcSTE(sfe, 
                sID, 
                data = sfe_logcnt_pca$x, 
                dMetric = "euclidean", 
                algorithm = "classic", 
                parameters = fgwc_param)

p1 <- plotFGWC_single(fgwc = fgwc, m_sfe = sfe, sample_id = sID)

p2 <- plotQC_spotsAnnotation(sfe, type = "hex", sample_id = sID)

p1 + p2

plotFGWC_multi(fgwc = fgwc, m_sfe = sfe, sample_id = sID)
```
