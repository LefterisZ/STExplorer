#' Plot global PCA results
#'
#' @name plotGWPCA_global
#' @description
#' A function to plot the global PCA results as generated by \code{gwpca.ste}.
#' Has to options, 'scree' and 'scatter'. The first will plot a scree plot of
#' the percentage of total variation of a selection of principal components. The
#' latter will produce a scatter plot of the two selected components.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste}.
#' @param comps the components to be plotted. If type == scree, it is a numeric
#' vector. If type == scatter, it is a numeric vector of length 2
#' (i.e., comps 1:2 will plot the two first components).
#' @param type either 'scree' or 'scatter'.
#' @param point_args arguments to pass to \code{geom_point()} when you don't
#' want them to be shared with \code{geom_line()}.
#' @param line_args arguments to pass to \code{geom_line()} when you don't
#' want them to be shared with \code{geom_point()}.
#' @param ... arguments to be passed to both \code{geom_point()} and
#' \code{geom_line()}.
#'
#' @returns A ggplot object.
#'
#' @importFrom ggplot2 geom_point geom_line ggplot labs theme ylim
#' @importFrom ggplot2 theme_classic aes scale_y_continuous element_text
#' @importFrom methods is
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @details
#' This function plots the results of a global principal component analysis. It
#' can generate two types of plots: a scree plot and a scatter plot.
#'
#' - The scree plot (type = "scree") shows the percentage of variation explained
#' by each component. It helps in determining the optimal number of components
#' to retain.
#'
#' - The scatter plot (type = "scatter") shows the scores of two components on
#' a two-dimensional plot. It requires running the gwpcaSTE function with the
#' scores argument set to TRUE to calculate the scores.
#'
#' The comps argument specifies the components to include in the plot. By
#' default, it includes the first 10 components. The point_args and line_args
#' arguments allow for customization of the appearance of the points and lines
#' in the plot, respectively.
#'
#' @examples
#' # Load gwpca data
#' data(gwpca)
#'
#' # Plot scree plot of PCA results
#' plotGWPCA_global(gwpca, type = "scree")
#'
#' \dontrun{
#' # To plot a scatter plot it requires you to run the [gwpcaSTE()] function
#' # with `scores = FALSE`.
#' # Plot scatter plot of PCA results for components 1 and 2
#' plotGWPCA_global(gwpca, type = "scatter", comps = c(1, 2))
#'
#' # Customize the appearance of points in the scatter plot
#' plotGWPCA_global(gwpca, type = "scatter",
#' point_args = list(size = 3, color = "red"))
#' }
#' @export
plotGWPCA_global <- function(gwpca,
                             comps = 1:10,
                             type = c("scree", "scatter"),
                             point_args = list(),
                             line_args = list(),
                             ...) {
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(is.list(point_args))
    stopifnot(is.list(line_args))

    ## Check valid type argument
    type <- match.arg(type)

    ## Prepare data
    if (type == "scree") {
        ## Calculate percent of variation explained
        pvar <- (gwpca$pca$sdev^2/sum(gwpca$pca$sdev^2))*100
        pvar <- data.frame(var = pvar,
                           PCs = sprintf("PC%03d", seq_along(pvar)))
        maxPct <- max(pvar$var)
    } else if (type == "scatter") {
        ## Extract scores for two components
        scores <- gwpca$pca$scores[, comps]
        if (is.null(scores)) {
            cat("To be able to plot a scatter plot of PCs you need to run the",
                "`gwpcaSTE` function with the `scores` argument set to TRUE.\n")
            stop()
        }
        df <- data.frame(scores[, comps[1]], scores[, comps[2]])
        colnames(df) <- sprintf("PC%d", seq_along(colnames(scores)))
    }

    ## Plot types for global PCA results
    plot_types <- list(
        scree = function(point_args, line_args, ...) {
            ggplot(pvar[comps,], aes(x = .data$PCs, y = .data$var, group = 1)) +
                do.call(geom_line, c(list(...), line_args)) +
                do.call(geom_point, c(list(...), point_args)) +
                labs(x = "Principal Component",
                     y = "% Variance Explained",
                     title = "Scree Plot") +
                scale_y_continuous(breaks = scales::pretty_breaks(n = 10),
                                   limits = c(0, maxPct + 5)) +
                theme_classic() +
                theme(axis.text.x = element_text(angle = 90,
                                                 vjust = 0.5,
                                                 hjust = 1))
        },
        scatter = function(point_args, ...) {
            ggplot(df, aes(x = df[,1], y = df[,2])) +
                do.call(geom_point, c(list(...), point_args)) +
                labs(x = paste0("Principal Component ", comps[1]),
                     y = paste0("Principal Component ", comps[2]),
                     title = paste0("PCA Plot of ", colnames(df)[1],
                                    " vs ", colnames(df)[2])) +
                theme_classic()
        }
    )

    ## Plot
    plot_fun <- plot_types[[type]]

    if (is.null(plot_fun)) {
        stop("Invalid type argument. Valid options are 'scree' and 'scatter'.")
    }

    ## Call plot function with arguments
    plot <- do.call(plot_fun,
                    c(list(point_args = point_args, line_args = line_args),
                      ...))

    ## Return plot
    return(plot)
}

#' Plot Leading Genes or Leading Gene Groups in GWPCA
#'
#' @name plotGWPCA_leadingG
#' @description
#' A function to map the leading genes or leading gene groups per location.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param arrange to indicate whether to arrange the plots in a panel or not.
#' The default is set to FALSE.
#' @param legend.position position of the plot legend. Default is right. Can
#' accept "bottom", "top", "right", and "left".
#' @param cutoff Numeric. The number of times a gene has to be the leading
#' gene in a location to be shown in the plot.
#' @param size Numeric. The legend text size.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the
#' aesthetic.
#'
#' @returns Returns a list of plots; one per Principal Component. If arrange ==
#' TRUE then a 2x2 panel is plotted too. If more than 4 PCs are provided in the
#' \code{comps} argument then only a list of plots is returned.
#'
#' @importFrom ggplot2 ggplot labs theme geom_sf aes
#' @importFrom ggplot2 theme_void scale_fill_manual
#' @importFrom gridExtra grid.arrange
#' @importFrom magrittr %>%
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @details
#' This function plots the leading genes or gene groups in a global weighted
#' principal component analysis (GWPCA). It can generate two types of plots:
#' individual plots for leading genes (type = "single") or a single plot for
#' gene groups (type = "multi").
#'
#' For type = "single", the function plots the leading genes individually. The
#' comps argument specifies the components for which to plot the leading genes.
#' The leading genes are represented as spatial polygons on a plot, where each
#' gene is coloured based on its score for the corresponding component. The ...
#' argument allows for customizing the appearance of the plots using additional
#' arguments passed to the geom_sf function.
#'
#' For type = "multi", the function plots the gene groups. The comps argument
#' specifies the components for which to plot the gene groups. The gene groups
#' are represented as spatial polygons on a single plot, where each group is
#' coloured based on the scores of the leading genes in that group. The ...
#' argument allows for customizing the appearance of the plot using additional
#' arguments passed to the geom_sf function.
#'
#' The arrange argument, when set to TRUE, arranges the individual plots in a
#' grid layout when the number of components specified is less than or equal to
#' 4. By default, the individual plots are returned as a list. If arrange is
#' TRUE and the number of components is greater than 4, a message is displayed,
#' and the individual plots are returned as a list.
#'
#' @examples
#' # Load gwpca data
#' data(gwpca)
#'
#' #Identify single leading gene per location for PC1 and PC2
#' gwpca <- gwpca_LeadingGene(gwpca = gwpca, sfe = sfe, pc_nos = c(1, 2),
#' type = "single", names = "id")
#'
#' # Identify top 3 leading genes per location for PC1 and PC2
#' gwpca <- gwpca_LeadingGene(gwpca = gwpca, sfe = sfe, pc_nos = c(1, 2),
#' type = "multi", genes_n = 3, method = "membership", names = "gene_names")
#'
#' # Plot individual leading genes for components 1 and 2
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2), type = "single")
#'
#' # Plot gene groups for components 1 and 2
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2), type = "multi")
#'
#' # Arrange individual plots in a grid layout
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2),
#' type = "single", arrange = TRUE)
#'
#' @export
plotGWPCA_leadingG <- function(gwpca,
                               comps,
                               type = c("single", "multi"),
                               arrange = FALSE,
                               legend.position = "right",
                               cutoff = 12,
                               size = 8,
                               ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "single") {
        lead.item <- gwpca$leadingGeneSingle
        fill <- "Leading\nGene"
    } else if (type == "multi") {
        lead.item <- gwpca$leadingGeneMulti
        fill <- "Group of\nLeading\nGenes"
    }

    ## Create a list of plots for each component
    plots <- lapply(comps,
                    .int_generatePlot,
                    cutoff = cutoff,
                    lead.item = lead.item,
                    fill = fill,
                    legend.position = legend.position,
                    size = size)

    ## Check if arrange is TRUE and comps length is less than or equal to 4
    if (arrange) {
      if (length(comps) <= 4) {
        n <- length(comps)
        nrow <- if (n %in% c(1, 2)) 1 else 2
        ncol <- if (n == 3) 2 else 2
        do.call(gridExtra::grid.arrange, c(plots, nrow = nrow, ncol = ncol))
        message("Plots arranged in a ", nrow, "x", ncol, " panel.")
      } else if (length(comps) > 4) {
        message("More than 4 components specified.\n",
                "Returning a list of individual plots.")
        return(plots)
      }
    } else {
      lapply(plots, print)
    }
}

#' Plot violins and map for Percent of Total Variation.
#'
#' @name plotGWPCA_ptv
#' @description
#' A function to plot and map the Percent of Total Variation (PTV) of the local
#' Principal Components for each location.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted. The maximum is based on the max
#' number of components used in the \code{gwpca.propVar} function. If one
#' component is provided here, then only one violin plot or map will be plotted.
#' If it is a numeric vector then the corresponding plots will be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param violin_args a list of arguments to be passed to \code{geom_violin()}
#' for customizing the violin plots. Defaults to an empty list.
#' @param box_args a list of arguments to be passed to \code{geom_boxplot()} for
#' customizing the boxplots. Defaults to an empty list.
#' @param fill_args a list of arguments to be passed to
#' \code{scale_fill_manual()} for customizing the fill colors of the plots.
#' Defaults to an empty list.
#' @param lab_args a list of arguments to be passed to \code{labs()} for
#' customizing the plot labels. Defaults to an empty list.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the
#' aesthetic.
#'
#' @importFrom gridExtra grid.arrange
#' @importFrom reshape2 melt
#' @importFrom ggplot2 geom_boxplot geom_sf geom_violin ggplot labs theme
#' @importFrom ggplot2 theme_classic theme_void facet_wrap aes
#' @importFrom ggplot2 scale_fill_viridis_c scale_fill_manual
#' @importFrom magrittr %>%
#' @importFrom dplyr n_distinct all_of
#'
#' @details
#' The comps argument is passed down to select the aggregates of components to
#' be plotted. Remember that PTVs are cumulative. This means that Comps_01
#' inside \code{gwpca$ptvs} shows the PTV for PC 1 per location. Next, Comps_02
#' shows the cumulative PTV for PCs 1 and 2 per location etc. As a result, when
#' you give `comps` = c(1, 5) then the violin plots for the cumulative PTV of
#' the first and the first 5 PCs per location will be plotted or mapped. If you
#' provide a single number then a single violin plot or map will be plotted. If
#' you provide a vector of numbers then a plot with multiple violins (arrange =
#' TRUE), or multiple single violins, or a panel of maps will be plotted, or
#' multiple single maps.
#'
#' @returns Returns a ggplot object.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load required packages
#' library(ggplot2)
#'
#' # Load data
#' data(gwpca)
#' data(sfe)
#'
#' # Add PTV data
#' gwpca <- gwpca_PropVar(gwpca = gwpca, n_comp = 2:10, sfe = sfe)
#'
#' # Plot PTV as violin plot
#' plotGWPCA_ptv(gwpca, comps = 1:5, type = "violin")
#'
#' # Plot PTV as map
#' plotGWPCA_ptv(gwpca, comps = 1:5, type = "map")
#'
#' @export
plotGWPCA_ptv <- function(gwpca,
                          comps,
                          type = c("violin", "map"),
                          violin_args = list(),
                          box_args = list(),
                          fill_args = list(),
                          lab_args = list(),
                          ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(!is.null(gwpca$ptvs))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "violin") {
        ptvs <- gwpca$ptvs[,!(colnames(gwpca$ptvs) %in% "geometry")] %>%
            .[, comps] %>%
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        col_ns <- colnames(gwpca$ptvs)[comps]
        ptvs <- gwpca$ptvs %>%
            select(all_of(c(col_ns, "geometry"))) %>%
            reshape2::melt(data = ., measure.vars = col_ns)
    }

    ## Set some defaults if not provided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1,
                         fill = "grey40",
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = getColours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }

    ## Set some defaults if not priovided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1,
                         fill = "grey40",
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = getColours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }

    ## List of plots
    plot_list <- list(
        violin = function(violin_args, box_args, labs_args, fill_args, ...){
            ggplot(ptvs, aes(x = .data$variable,
                             y = .data$value,
                             fill = .data$variable)) +
                do.call(geom_violin, c(list(...), violin_args)) +
                do.call(scale_fill_manual, c(fill_args)) +
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(labs, labs_args) +
                ylim(0, 100) +
                theme_classic() +
                theme(axis.text.x = element_text(angle = 90,
                                                 vjust = 0.5,
                                                 hjust = 1))
        },
        map = function(comps, labs_args, ...){
            ggplot(data = ptvs) +
                geom_sf(aes(geometry = .data$geometry,
                            fill = .data$value), ...) +
                scale_fill_viridis_c(option = "magma", limits = c(0, 100)) +
                facet_wrap(~variable, ncol = ceiling(sqrt(n_distinct(comps)))) +
                do.call(labs, labs_args) +
                theme_void() +
                theme(legend.position = "right")
        }
    )

    ## Get the required plot function
    plot_fun <- plot_list[[type]]

    ## Fetch appropriate arguments
    if (type == "violin") {
        args_list <- list(violin_args = violin_args,
                          box_args = box_args,
                          labs_args = labs_args,
                          fill_args = fill_args)
    } else if (type == "map") {
        args_list <- list(comps = comps,
                          labs_args = labs_args)
    }

    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun,
                    c(list(...), args_list))

    return(plot)
}


#' Visualise outliers in box-plot or map
#'
#' @name plotGWPCA_discr
#'
#'
#' @description
#' This function plots discrepancies using either a boxplot or a map. It
#' visualizes the discrepancies in the local Principal Components (PCs) for each
#' location based on the coefficient of variation (CV).
#'
#' @param gwpca A list of class `gwpca` containing the necessary data.
#' @param type Specifies the type of plot to generate. Can be either "box" for
#' a boxplot or "map" for a map. Default is "box".
#' @param box_args Additional arguments to customize the appearance of the
#' boxplot.
#' @param jitt_args Additional arguments to customize the appearance of the
#' jitter points in the boxplot.
#' @param hline_args Additional arguments to customize the appearance of the
#' horizontal line in the boxplot.
#' @param lab_args Additional arguments to customize the labels of the plot.
#' @param ... Additional arguments to be passed to the `geom_boxplot()` or
#' `geom_sf()` functions.
#'
#' @details
#' # Dependencies
#' The function depends on the `ggplot2` and `sf` packages.
#'
#' The function first checks the validity of the input arguments. It then
#' fetches the necessary data from the `gwpca` object and calculates the
#' outliers using the `outlier_cutoff()` function. Depending on the `type`
#' specified, the data is prepared accordingly for either a boxplot or a map.
#'
#' For the boxplot, the discrepancies (`cvs`) are reshaped into a data frame and
#' plotted using `geom_boxplot()`. Jitter points can also be added using
#' `geom_jitter()`. A horizontal line is drawn at the upper outlier threshold.
#' Customization of the plot appearance is possible through the provided
#' arguments.
#'
#' For the map, the discrepancies, along with the geometry information, are
#' combined into a data frame. The map is then created using `geom_sf()`, with
#' the discrepancies represented by fill color. Outliers are also marked with a
#' transparent fill color and a black border. Customization options for the map
#' appearance are available through the arguments.
#'
#' @importFrom ggplot2 aes coord_flip element_blank facet_wrap geom_boxplot
#' @importFrom ggplot2 geom_hline geom_jitter geom_sf ggplot labs  theme
#' @importFrom ggplot2 scale_fill_viridis_c theme_classic theme_void
#' @importFrom dplyr mutate if_else
#' @importFrom reshape2 melt
#' @importFrom scales alpha
#' @importFrom magrittr %>%
#' @importFrom S4Vectors isEmpty
#'
#' @returns The function returns the created plot.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load data
#' data(gwpca)
#'
#' # Plot discrepancies as a boxplot
#' plotGWPCA_discr(gwpca, type = "box")
#'
#' # Plot discrepancies as a map
#' plotGWPCA_discr(gwpca, type = "map")
#'
#' @export
plotGWPCA_discr <- function(gwpca,
                            type = c("box", "map"),
                            box_args = list(),
                            jitt_args = list(),
                            hline_args = list(),
                            lab_args = list(),
                            ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(!is.null(gwpca$geometry))
    stopifnot(!is.null(gwpca$CV))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "box") {
        discs <- data.frame(cvs = gwpca$CV$CV) %>%
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        discs <- data.frame(cvs = gwpca$CV$CV,
                            is_disc = gwpca$CV$is_outlier,
                            geometry = gwpca$geometry) %>%
            mutate(out_geom = .data$geometry,
                   out_geom = if_else(.data$is_disc == FALSE,
                                      NA,
                                      .data$out_geom))
    }

    ## Set some defaults if not provided
    if (isEmpty(box_args) & type == "box") {
        box_args <- list(width = 0.8,
                         fill = "#D1E5F0",
                         colour = "#2166AC",
                         outlier.colour = "red",
                         outlier.size = 2)
    }
    if (isEmpty(jitt_args) & type == "box") {
        jitt_args <- list(col = "#EF8A62",
                          size = 2,
                          width = 0.3,
                          alpha = 0.8)
    }
    if (isEmpty(hline_args) & type == "box") {
        hline_args <- list(yintercept = gwpca$CV$out_up,
                           linetype = "dashed",
                           color = "royalblue")
    }
    if (isEmpty(lab_args) & type == "box") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          x = "",
                          y = "Discrepancy score")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          fill = "Discrepancy\nscore")
    }

    ## List of plots
    plot_list <- list(
        box = function(box_args, jitt_args, hline_args, labs_args, ...){
            ggplot(discs, aes(x = .data$variable, y = .data$value)) +
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(geom_jitter, c(list(...), jitt_args)) +
                do.call(geom_hline, c(list(...), hline_args)) +
                do.call(labs, labs_args) +
                coord_flip() +
                theme_classic() +
                theme(axis.text.y = element_blank(),
                      axis.ticks.y = element_blank())
        },
        map = function(labs_args, ...){
            ggplot(data = discs) +
                geom_sf(aes(geometry = .data$geometry, fill = .data$cvs),
                        colour = NA, ...) +
                geom_sf(aes(geometry = .data$out_geom),
                        fill = alpha("white", 0),
                        colour = "black",
                        linewidth = 0.5) +
                scale_fill_viridis_c(option = "inferno",) +
                do.call(labs, labs_args) +
                theme_void() +
                theme(legend.position = "right")
        }
    )

    ## Get the required plot function
    plot_fun <- plot_list[[type]]

    ## Fetch appropriate arguments
    if (type == "box") {
        args_list <- list(box_args = box_args,
                          jitt_args = jitt_args,
                          hline_args = hline_args,
                          labs_args = labs_args)
    } else if (type == "map") {
        args_list <- list(labs_args = labs_args)
    }

    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun,
                    c(list(...), args_list))

    return(plot)

}


#' Plot GWPCA Discrepancy Heatmap
#'
#' Generates a discrepancy heatmap based on GWPCA results for specific tissue
#' locations.
#' @name plotGWPCA_discrHeatmap
#'
#' @param m_sfe a SpatialFeatureExperiment or a MetaSpatialFeatureExperiment
#'  object.
#' @param assay Assay type for the spatial expression data (counts, logcounts
#' etc.).
#' @param vars Variables of interest (genes) to be evaluated. Default is NULL,
#' which includes all variables.
#' @param focus Tissue locations of interest (barcodes) for which discrepancy
#' heatmaps will be generated.
#' @param dMetric Distance metric used for generating the distance matrix which
#' will be used to identify the focus location's neighbours.
#' @param sample_id Sample ID for which discrepancy data is retrieved.
#' @param diam Bandwidth parameter for selecting neighbours for the heatmap.
#' @param mean.diff Threshold for selecting genes based on the difference from
#' the mean discrepancy score.
#' @param show.vars Display option for variables (genes) in the heatmap. Options
#' are "top" (genes with higher discrepancies) or "all" (all genes).
#' @param scale Scaling method for the heatmap. Options are "row" (row scaling)
#' or "none" (no scaling).
#' @param gene.names Logical indicating whether to display gene names instead of
#' ENSGene IDs.
#' @param ... Additional arguments to be passed to the pheatmap function.
#'
#' @details This function generates discrepancy heatmaps based on GWPCA results
#' for specific tissue locations (focus). It retrieves the discrepancy data
#' using the `gwpca_Discrepancy` function, annotates the columns with distance
#' information, generates annotation colors based on distance levels, and plots
#' the heatmap using the `pheatmap` function.
#'
#' @importFrom pheatmap pheatmap
#' @importFrom dplyr select starts_with left_join mutate if_else ends_with
#' @importFrom tibble rownames_to_column column_to_rownames
#' @importFrom scales grey_pal
#' @importFrom magrittr %>%
#'
#' @returns plots a heatmap.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load data
#' data(sfe)
#'
#' # Set parameters
#' assay <- "logcounts"
#' focus <- colnames(sfe)[1] # outlier Barcode
#' sample_id <- "JBO019"
#' dMetric <- "euclidean"
#' bw <- 450
#' show.vars <- "top"
#'
#' # Plot
#' plotGWPCA_discrHeatmap(sfe, assay = assay,
#' focus = focus,
#' dMetric = dMetric, sample_id = sample_id,
#' bw = bw, mean.diff = 1, show.vars = show.vars, scale = "row",
#' gene.names = TRUE)
#'
#' @export
plotGWPCA_discrHeatmap <- function(m_sfe,
                                   assay,
                                   vars = NULL,
                                   focus,
                                   dMetric,
                                   sample_id,
                                   diam,
                                   mean.diff = 1,
                                   show.vars = c("top", "all"),
                                   scale = "row",
                                   gene.names = FALSE,
                                   ...) {
    for (i in focus) {
      ## SFE or metaSFE?
      sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

      ## Get the discrepancy data
      dt.focus.list <- getDiscrepancyGeneData(m_sfe = sfe,
                                              assay = assay,
                                              vars = vars,
                                              focus = i,
                                              dMetric = dMetric,
                                              sample_id = sample_id,
                                              diam = diam,
                                              mean.diff = mean.diff,
                                              exportExpression = FALSE)
      data.focus <- dt.focus.list$data.focus

      ## Annotate the columns with distance information
      nbr.annotation <- data.focus %>%
          dplyr::select(.data$Distance)

      ## Generate annotation colors based on distance levels
      nbr.lvls <- with(nbr.annotation, table(Distance))
      nbr.ann.colours <- grey_pal(start = 0, end = 0.8)(length(nbr.lvls))
      nbr.ann.colours[1] <- "red" # Make the focus point red
      nbr.ann.colours <- rep(nbr.ann.colours, times = nbr.lvls)
      nbr.ann.colours <- list(Distance = nbr.ann.colours)

      ## Drop distance
      data.focus <- data.focus %>%
          dplyr::select(starts_with("ENSG")) %>%
          t() %>%
          as.data.frame()

      ## Translate the ENSGene IDs to Gene names
      if (gene.names) {
          data.focus <- data.focus  %>%
              rownames_to_column(var = "id") %>%
              left_join(dt.focus.list$annot) %>%
              mutate(gene_name = if_else(is.na(.data$gene_name),
                                         .data$id,
                                         .data$gene_name)) %>%
              column_to_rownames(var = "gene_name") %>%
              select(ends_with("-1"))
      }

      ## Plot the heatmap
      pheatmap(data.focus,
               scale = scale,
               annotation_col = nbr.annotation,
               annotation_colors = nbr.ann.colours,
               ...)
    }
}


#' Plot Functional Clustering Results from GWPCA
#'
#' This function generates a series of spatial plots representing various
#' aspects of functional clustering results obtained from Gene Set Enrichment
#' Analysis (GSEA) combined with Geometrically Weighted Principal Component
#' Analysis (GWPCA).
#'
#' @param gsea_map A spatial dataset containing functional clustering results,
#' typically obtained from the output of the
#' \code{\link{gwpca_FunctionalClustering}} function.
#' @param count An integer specifying the minimum count required for a cluster
#' to be displayed in the legend.
#' @param legend A character string specifying the legend position. The
#' arguments are the \code{ggplot2}'s \code{legend.position} arguments: "top",
#' "bottom", "left", "right".
#' @param legend.title A character string specifying the legend title.
#' @import patchwork
#' @importFrom dplyr rename arrange filter select mutate
#' @importFrom ggplot2 scale_fill_viridis_d scale_fill_manual
#' @importFrom ggplot2 scale_fill_gradient2 scale_fill_viridis_c
#'
#' @return A grid of spatial plots representing different aspects of functional
#' clustering results.
#'
#' @examples
#' # Example usage:
#' # plotGWPCA_FuncCLust(gsea_map, count = 5, legend = "right")
#'
#' @keywords plot visualisation functional clustering gwpca gsea
#' @family Spatial Transcriptomics Analysis
#'
#' @export
plotGWPCA_FuncCLust <- function(gsea_map, count = 5, legend, legend.title) {
  ## The Legend labels
  lookup <- c(cluster = "Var1", freq = "Freq")
  spot_labels <- data.frame(table(gsea_map$cluster)) %>%
    dplyr::rename(all_of(lookup)) %>%
    dplyr::arrange(dplyr::desc(freq)) %>%
    mutate(show = ifelse(freq > count, TRUE, FALSE))

  ## The legend breaks:
  spot_breaks <- spot_labels %>%
    dplyr::filter(show == TRUE) %>%
    dplyr::arrange(cluster) %>%
    dplyr::select(cluster) %>%
    .[["cluster"]] %>%
    as.vector()
  n_cols1 <- ceiling(length(unique(gsea_map$genes_no)) / 10)
  n_cols2 <- ceiling(length(unique(gsea_map$setSize)) / 10)

  ## The colours:
  col_No <- length(unique(gsea_map$cluster))
  colour_values <- getColours(col_No)
  names(colour_values) <- spot_labels$cluster

  ## The plots:
  gsea_plots <- list()

  gsea_plots[[1]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = cluster),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_manual(values = colour_values,
                      breaks = spot_breaks,
                      na.value = "grey95") +
    labs(title = NULL,
         fill = legend.title) +
    theme_void() +
    theme(legend.position = legend)

  gsea_plots[[2]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = NES),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_gradient2(high = "#B2182B",
                         mid = "#F7F7F7",
                         low = "#2166AC",
                         midpoint = 0,
                         n.breaks = 7,
                         na.value = "grey95") +
    labs(title = NULL,
         fill = "Normalised\nEnrichment\nScore") +
    theme_void()

  gsea_plots[[3]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = -log10(p.adjust)),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_viridis_c(option = "magma",
                         na.value = "grey95") +
    labs(title = NULL,
         fill = "-log10\nAdjusted\np-value") +
    theme_void()

  gsea_plots[[4]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = rank),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_viridis_c(option = "magma",
                         na.value = "grey95") +
    labs(title = NULL,
         fill = "Rank") +
    theme_void()

  gsea_plots[[5]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = as.factor(genes_no)),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_viridis_d(option = "magma",
                         na.value = "grey95") +
    labs(title = NULL,
         fill = "Number of\ngenes from\nranked list") +
    theme_void() +
    ggplot2::guides(fill = ggplot2::guide_legend(ncol = n_cols1, byrow = TRUE))

  gsea_plots[[6]] <- ggplot() +
    geom_sf(data = gsea_map,
            aes(geometry = geometry,
                fill = as.factor(setSize)),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_viridis_d(option = "magma",
                         na.value = "grey95") +
    labs(title = NULL,
         fill = "Gene set\nSize") +
    theme_void() +
    ggplot2::guides(fill = ggplot2::guide_legend(ncol = n_cols2, byrow = TRUE))

  ## Arrange plots
  (gsea_plots[[1]]|gsea_plots[[2]])/(gsea_plots[[3]]|gsea_plots[[4]]|gsea_plots[[5]]|gsea_plots[[6]])

}


#' Plot Leading Scores from GWPCA
#'
#' This function plots leading scores for specific genes from a GWPCA object.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#'              updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted. Can be either in a `c(1,3,5)` or
#'              in a `1:3` form.
#' @param genes A vector of ENSG_IDs to be plotted. At the moment, gene names
#'              are not supported.
#' @param type Character vector specifying the type of spatial data
#'             to use for plotting. Options are "spot" for spot
#'             geometry and "hex" for hexagon geometry. Default is
#'             "spot".
#' @param colours One of either "viridis" or "custom". Select between Viridis'
#'                package colour schemes and custom colours provided by you.
#'                IMPORTANT: Look at Details for more information.
#' @param col_args List of arguments to customise the map fill colour.
#'                 Default is an empty list. If you select "viridis" at the
#'                 `colours` argument, here you can select the colour scheme
#'                 you prefer. I.e., `list(option = "magma")`.
#' @param gene_names A character vector with the corresponding gene names for
#'                   the ENSG IDs you provided in the `genes` argument.
#'                   IMPORTANT: the order of names must match that of the ENSG
#'                   IDs.
#'
#' @details
#' About using custom colours:
#' At the moment, the function is implementing `scale_fill_gradientn` which
#' expects a gradient like the ones generated by `colorRampPalette`. For
#' example: `colors <- colorRampPalette(c("blue", "red"))(100)`
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords spatial gwpca leading-scores plot map
#'
#' @rdname plotGWPCA_leadingScores
#' @aliases plotGWPCA_leadingScores
#'
#' @importFrom DelayedArray isEmpty
#' @importFrom ggplot2 geom_sf facet_grid labs coord_sf theme_void
#' @importFrom ggplot2 scale_fill_viridis_c scale_fill_gradientn
#'
#' @export
plotGWPCA_leadingScores <- function(gwpca,
                                    comps,
                                    genes,
                                    type = c("spot", "hex"),
                                    colours = c("viridis", "custom"),
                                    col_args = list(),
                                    gene_names) {
  ## DEV. NOTE: maybe add a locs argument to give specific locations for which
  ## to collect data and make the plot?

  ## Check type argument
  if (missing(type)) {
    type <- "hex"
  }
  if (type == "hex") {
    stopifnot("spotHex" %in% names(colGeometries(sfe)))
    type <- "spotHex"
  } else if (type == "spot") {
    type <- "spotPoly"
  }

  ## Fetch the data
  data <- .int_prepDtMapGWPCA(gwpca = gwpca,
                              locs = NULL, # not used currently
                              comps = comps,
                              genes = genes,
                              type = type,
                              gene_names = gene_names)

  ## Set some defaults if not provided
  if (missing(colours)) {
    colours <- "viridis"
  }
  if (DelayedArray::isEmpty(col_args) & colours == "viridis") {
    col_args <- list(option = "viridis")
  } else if (DelayedArray::isEmpty(col_args) & colours == "custom") {
    stop("When selecting custom colours, `col_args` must not be empty.")
  }

  ## Generate plot
  p <- ggplot(data) +
    ggplot2::geom_sf(aes(geometry = geometry, fill = leadScore)) +
    ggplot2::facet_grid(rows = ggplot2::vars(data$gene),
                        cols = ggplot2::vars(data$pcs))

  if (colours == "viridis") { # Which colours?
    p <- p + do.call(scale_fill_viridis_c, c(list(), col_args))
  } else if (colours == "custom") {
    p <- p + do.call(scale_fill_gradientn, c(list(), col_args))
  }

  p + # finalise plot
    ggplot2::labs(fill = "Absolute\nLeading\nscore") +
    ggplot2::coord_sf() +
    ggplot2::theme_void()
}


# ---------------------------------------------------------------------------- #
#  ############# INTERNAL FUNCTIONS ASSOCIATED WITH GWPCA PLOTS #############
# ---------------------------------------------------------------------------- #
#' Internal Function: Generate Spatial Plot for a Principal Component
#'
#' This function generates a spatial plot for a specified principal component
#' (PC) using the given parameters.
#'
#' @param pc.No The principal component number to plot.
#' @param cutoff The cutoff threshold for displaying legend labels.
#' @param lead.item The lead item containing spatial information.
#' @param fill The label for the fill aesthetic in the plot.
#' @param legend.position The position of the legend in the plot.
#' @param size The size of legend text in the plot.
#'
#' @return A ggplot2 object representing the spatial plot for the specified
#' principal component.
#'
#' @details The function generates a spatial plot using the specified principal
#' component, lead item, and other parameters. It utilises ggplot2 for creating
#' the plot and allows customization of legend labels, colours, and other
#' visual elements.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords spatial plot, principal component, ggplot2
#'
#' @rdname dot-int_generate_plot
#'
.int_generatePlot <- function(pc.No,
                               cutoff,
                               lead.item,
                               fill,
                               legend.position,
                               size) {
  ## The Legend labels
  spot_labels <- data.frame(table(lead.item[pc.No])) %>%
    dplyr::rename(LeadingGs = colnames(lead.item)[pc.No],
                  count = .data$Freq) %>%
    dplyr::arrange(dplyr::desc(.data$count)) %>%
    mutate(show = ifelse(.data$count > cutoff, TRUE, FALSE))

  ## The legend breaks:
  spot_breaks <- spot_labels %>%
    dplyr::filter(.data$show == TRUE) %>%
    dplyr::arrange(.data$LeadingGs) %>%
    dplyr::select(.data$LeadingGs) %>%
    .[["LeadingGs"]] %>%
    as.vector()
  n_cols <- ceiling(sum(spot_labels$show) / 10)

  ## The colours:
  col_No <- sum(spot_labels$show)
  colour_values <- getColours(col_No)
  names(colour_values) <- spot_labels$LeadingGs[spot_labels$show]
  pc <- paste0("PC", pc.No)

  ## The Plot:
  p <- ggplot() +
    geom_sf(data = lead.item,
            aes(geometry = .data[["geometry"]][["geometry"]],
                fill = .data[[pc]]),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_manual(values = colour_values,
                      breaks = spot_breaks,
                      na.value = "gray95") +
    labs(title = pc,
         fill = fill) +
    theme_void() +
    theme(legend.position = legend.position,
          legend.text = ggplot2::element_text(size = size)) +
    ggplot2::guides(fill = ggplot2::guide_legend(ncol = n_cols, byrow = TRUE))

  return(p)
}


#' Internal: prepare Data Map for GWPCA
#'
#' A function to prepare data for plotting leading scores for specific genes
#' from a GWPCA object.
#'
#' @param gwpca An object of class 'gwpca' containing GWPCA data.
#' @param locs locations to select -- currently out of use --> select all
#' @param comps the components to be plotted.
#' @param genes A vector of gene names or ENSG_IDs to be plotted.
#' @param type Character vector specifying the type of spatial data
#'             to use. Options are "spot" for spot geometry and "hex"
#'             for hexagon geometry.
#'
#' @return A data frame containing leading score gene data prepared for
#'         plotting on a map.
#'
#' @importFrom dplyr mutate
#' @importFrom tidyr pivot_longer
#' @importFrom rlist list.rbind
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords spatial plot, principal component, ggplot2, leading scores
#'
#' @rdname dot-int_prepDtMapGWPCA
#'
.int_prepDtMapGWPCA <- function(gwpca,
                                locs,
                                genes,
                                comps,
                                type,
                                gene_names) {
  genes_ar <- gwpca$loadings[,genes,comps]

  if (!is.null(gene_names)) {
    if (is.character(gene_names)) {
      colnames(genes_ar) <- gene_names
    }
  }

  genes_lst <- lapply(seq_along(comps), .int_arrayToListGWPCA)

  genes_dt <- rlist::list.rbind(genes_lst)

  geoms <- gwpca$geometry %>%
    tibble::rownames_to_column(var = "rownames")

  out <- dplyr::right_join(geoms, genes_dt, by = 'rownames') %>%
    tidyr::pivot_longer(cols = -c("rownames", "geometry", "pcs"),
                        names_to = "gene",
                        values_to = "leadScore") %>%
    dplyr::mutate(leadScore = abs(leadScore))

  if (gene_names) {
    out <- out %>%
      dplyr::mutate()
  }

  return(out)
}


#' @rdname dot-int_prepDtMapGWPCA
#' @keywords internal
#' @author Eleftherios (Lefteris) Zormpas
.int_arrayToListGWPCA <- function(x) {
  genes_ar[,,x] %>%
    as.data.frame() %>%
    tibble::rownames_to_column(var = "rownames") %>%
    dplyr::mutate(pcs = dimnames(genes_ar)[[3]][x])
}
