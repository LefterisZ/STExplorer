#' Plot Decrease in Reconstruction Error versus Random Noise
#'
#' This function plots the decrease in reconstruction error versus random noise.
#' The point where the change in reconstruction error matches the change in
#' reconstruction error for the randomized matrix is the optimal number of
#' factors to use.
#'
#' @param kErrDiff Reduction in reconstruction error above noise output by
#' `fgwc_nmfFactorNumber`.
#' @param font.size Font size to use for plotting (default is 12).
#'
#' @return A ggplot object showing the decrease in reconstruction error versus
#' random noise.
#'
#' @details
#' The function generates a plot that visualizes the reduction in
#' reconstruction error above noise for different numbers of factors. The
#' optimal number of factors is where the error reduction matches the change
#' in reconstruction error for the randomized matrix.
#'
#' @examples
#' \dontrun{
#' # Example data for reduction in reconstruction error
#' k_err_diff <- fgwc_
#' plotFGWC_factorSelection(k_err_diff, font.size = 10)
#' }
#'
#' @seealso \code{\link[ggplot2]{ggplot}} for additional details on plotting.
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords clustering spatial-expression nmf
#' @family clustering functions
#' @rdname plotFGWC_factorSelection
#' @aliases plotFGWC_factorSelection
#' @export
plotFGWC_factorSelection <- function(kErrDiff, font.size = 12) {
  # Ensure kErrDiff is a named numeric vector
  if (is.list(kErrDiff)) {
    k <- kErrDiff$k
    kErrDiff <- kErrDiff[["err"]]
  } else {
    stop("The `kErrDif` argument must be a list as generated by",
         "`fgwc_nmfFactorNumber`")
  }

  # Convert kErrDiff to a data frame directly
  errorDF <- data.frame(x = factor(names(kErrDiff), levels = names(kErrDiff)),
                        y = unname(kErrDiff))

  # Get best k position
  bestK <- errorDF[errorDF$x == k,]

  # Create the ggplot object
  ggplot(data = errorDF, aes(x = x, y = y)) +
    geom_line(group = 1) +
    geom_point(size = 4) +
    geom_point(data = bestK,
               aes(x = x, y = y),
               shape = 21, colour = "black", fill = "#69b3a2", size = 6) +
    theme_classic() +
    labs(x = "Number of factors",
         y = "Error reduction above noise") +
    theme(axis.text.x = element_text(hjust = 1,
                                     size = font.size,
                                     colour = "black"),
          axis.text = element_text(size = font.size, colour = "black"),
          axis.title = element_text(size = font.size, colour = "black"),
          legend.position = "none") +
    geom_hline(yintercept = 0.0, linetype = "dashed", colour = "darkred")
}


#' Plot Single Cluster Result for Fuzzy Geographically Weighted Clustering
#' (FGWC)
#'
#' This function plots the result of Fuzzy Geographically Weighted Clustering
#' (FGWC) for a single cluster. The selected cluster is the cluster with the
#' highest membership percentage for each location.
#'
#' @param fgwc The result of FGWC clustering.
#' @param m_sfe The spatial feature experiment (SFE) or metaSFE object.
#' @param sample_id The sample ID.
#' @param colours A vector of colours for the clusters. If NULL, default
#' colours will be used.
#'
#' @return A ggplot object.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' nmf <- fgwc_nmf(m_sfe, sample_id, top_hvgs, ncomponents = 2,
#' ntop = 600)
#' fgwc_result <- fgwc(m_sfe, sample_id, data = nmf)
#' plotFGWC_single(fgwc_result, m_sfe, sample_id)
#' }
#'
#' @seealso
#' \code{\link{fgwc_nmf}}, \code{\link{plotFGWC_multi}},
#' \code{\link{plotFGWC_heatmap}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords clustering fuzzy-logic spatial ggplot2 visualization fgwc
#' @family plotting functions
#' @rdname plotFGWC_singleMap
#' @aliases plotFGWC_single
#'
#' @export
plotFGWC_singleMap <- function(fgwc,
                               m_sfe,
                               sample_id,
                               colours = NULL) {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Prepare data to plot
  data <- .int_fgwcPlotDataMap(fgwc = fgwc, sfe = sfe, mode = "single")

  ## Fetch colours
  if (is.null(colours)) {
    col.No = length(unique(fgwc$cluster))
    annot_cols <- getColours(col.No)
  } else {
    annot_cols <- colours
  }

  ## Plot single cluster
  ggplot() +
    geom_sf(data = data,
            aes(geometry = geometry,
                fill = as.factor(Cluster)),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_manual(values = annot_cols) +
    labs(title = NULL,
         fill = "Cluster") +
    theme_void() +
    theme(legend.position = "right")

}

#' Plot Multiple Cluster Results for Fuzzy Geographically Weighted Clustering
#' (FGWC)
#'
#' This function plots the results of Fuzzy Geographically Weighted Clustering
#' (FGWC) for multiple clusters. It plots the membership percentage of each
#' cluster in each location.
#'
#' @param fgwc The result of FGWC clustering.
#' @param m_sfe The spatial feature experiment (SFE) or metaSFE object.
#' @param sample_id The sample ID.
#' @param palette The color palette for the cluster memberships.
#' Default is "YlGnBu".
#'
#' @return A ggplot object.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' fgwc_result <- fgwc_nmf(m_sfe, sample_id, top_hvgs, ncomponents = 2,
#' ntop = 600)
#' plotFGWC_multi(fgwc_result, m_sfe, sample_id)
#' }
#'
#' @seealso
#' \code{\link{fgwc_nmf}}, \code{\link{plotFGWC_single}},
#' \code{\link{plotFGWC_heatmap}}
#'
#' @details
#' The function produces a panel of maps. One map per cluster. The colours in
#' all maps are scaled to be the same. Meaning that the colour for 50% in map 1
#' is going to be the same with colour for 50% in map 3.
#'
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 scale_fill_distiller
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords clustering fuzzy-logic spatial ggplot2 visualization fgwc
#' @family plotting functions
#' @rdname plotFGWC_multiMap
#' @aliases plotFGWC_multi
#'
#' @export
plotFGWC_multiMap <- function(fgwc,
                              m_sfe,
                              sample_id,
                              palette = "YlGnBu") {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Prepare data to plot
  data <- .int_fgwcPlotDataMap(fgwc = fgwc, sfe = sfe, mode = "multi") %>%
    tidyr::pivot_longer(cols = !.data$geometry,
                        names_to = "cluster",
                        values_to = "membership")

  ggplot() +
    geom_sf(data = data,
            aes(geometry = geometry,
                fill = membership),
            colour = "grey30",
            show.legend = TRUE) +
    scale_fill_distiller(palette = palette, limits = c(0, 1)) +
    facet_wrap(~cluster) +
    labs(fill = "Cluster\nmembership") +
    theme_void() +
    theme(legend.position = "right")

}


#' Plot Membership percentages from FGWC per annotation or winning cluster
#'
#' This function plots the results of Fuzzy Geographically Weighted Clustering
#' (FGWC) for multiple clusters. It plots the membership percentage of each
#' cluster in each location as violin plots.
#'
#' @param fgwc The result of FGWC clustering.
#' @param m_sfe The spatial feature experiment (SFE) or metaSFE object.
#' @param sample_id The sample ID.
#'
#' @return A ggplot object.
#'
#' @seealso
#' \code{\link{fgwc_nmf}}, \code{\link{plotFGWC_single}},
#' \code{\link{plotFGWC_heatmap}}
#'
#' @details
#' The function produces a set of violin plots. One set per annotation or
#' winning cluster
#'
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 scale_fill_viridis_d
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords clustering fuzzy-logic spatial ggplot2 visualization fgwc
#' @family plotting functions
#' @rdname plotFGWC_multiViolin
#' @aliases plotFGWC_multiViolin
#'
#' @export
plotFGWC_multiViolin <- function(fgwc, m_sfe, sample_id = NULL) {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Prepare data to plot
  data <- .int_fgwcPlotDataViolin(fgwc = fgwc, sfe = sfe) %>%
    tidyr::pivot_longer(cols = -all_of(c("annotation", "Cluster")),
                        names_to = "cluster",
                        values_to = "membership")

  ggplot(data = data,
         aes(x = cluster, y = membership)) +
    geom_violin(aes(fill = cluster),
                width = 1,
                show.legend = TRUE,
                trim = FALSE) +
    geom_boxplot(width = 0.1, colour = "black", alpha = 0.2,
                 outlier.size = 0.5, outlier.alpha = 0.2) +
    scale_fill_viridis_d() +
    facet_wrap(~annotation) +
    labs(x = "",
         y = "Membership %",
         fill = "Cluster") +
    theme_classic() +
    theme(legend.position = "right",
          strip.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
          axis.text.y = element_text(size = 17),
          axis.title.y = element_text(size = 17),
          legend.text = element_text(size = 12),
          legend.title = element_text(size = 17))

}


#' Plot NMF Factors as a Map
#'
#' This function plots the Non-Negative Matrix Factorization (NMF) factors as a map.
#'
#' @param nmf The NMF result object. As generated by STExplorer's `fgwc_nmf`
#' function.
#' @param m_sfe The SpatialFeatureExperiment (SFE) or metaSFE object.
#' @param sample_id The sample ID.
#'
#' @return A ggplot object.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' plotFGWC_nmfFactorsMap(nmf_result, m_sfe, sample_id)
#' }
#'
#' @seealso \code{\link{nmf}}, \code{\link{plotFGWC_single}},
#' \code{\link{plotFGWC_multi}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords nmf factorization spatial ggplot2 visualization
#' @family plotting functions
#' @rdname plotFGWC_nmfFactorsMap
#' @aliases plotFGWC_nmfFactorsMap
#'
#' @export
plotFGWC_nmfFactorsMap <- function(nmf, m_sfe, sample_id = NULL) {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Prepare data to plot
  data <- .int_nmfPlotDataMap(nmf = nmf, sfe = sfe)

  ## Plot
  ggplot(data = data) +
    geom_sf(aes(geometry = geometry, fill = score)) +
    facet_wrap(~ Factors) +
    scale_fill_viridis_c() +
    labs(fill = "Factor\nScore") +
    theme_void()
}


#' Plot FGWC NMF Factors Heatmap
#'
#' This function generates a clustered heatmap of factor scores obtained from
#' FGWC (Fuzzy Geographically Weighted Clustering) analysis. It allows for
#' optional annotations based on clusters or annotations.
#'
#' @param fgwc An object of class `fgwc` containing the results of FGWC
#' analysis.
#' @param loc_annot A character string specifying the type of annotations to
#' include in the heatmap. Possible values are:
#'   \itemize{
#'     \item `"annotation"`: Include only the annotation column.
#'     \item `"cluster"`: Include only the cluster column.
#'     \item `"both"`: Include both annotation and cluster columns.
#'     \item `"none"`: Include no annotations.
#'   }
#'   Defaults to `"both"`.
#'
#' @param order_rows order rows based on annotation or cluster. Possible values
#' are:
#'   \itemize{
#'     \item `"annotation"`: Order by the annotation column (alphabetical).
#'     \item `"cluster"`: Order by the cluster column (alphabetical).
#'     \item `"none"`: No ordering annotations (rows are clustered then).
#'   }
#'   Defaults to `"none"`.
#' @param ... Arguments passed to `pheatmap`.
#'
#' @returns A heatmap plot of factor scores with optional annotations.
#' @importFrom dplyr select contains all_of any_of mutate
#' @importFrom pheatmap pheatmap
#' @importFrom cols4all c4a
#'
#' @examples
#' \dontrun{
#' # Assuming `fgwc_object` is a valid FGWC object
#' plotFGWC_nmfFactorsHeatmap(fgwc_object, loc_annot = "both")
#' plotFGWC_nmfFactorsHeatmap(fgwc_object, loc_annot = "annotation")
#' plotFGWC_nmfFactorsHeatmap(fgwc_object, loc_annot = "none")
#' }
#'
#' @export
plotFGWC_nmfFactorsHeatmap <- function(fgwc,
                                       loc_annot = c("annotation", "cluster",
                                                     "both", "none"),
                                       order_rows = c("annotation", "cluster",
                                                      "none"),
                                       ...) {
  ## Check fgwc argument is of class fgwc
  .int_checkFGWCClass(fgwc)

  ## Prepare data for heatmap
  data_in <- .int_getFactorData(fgwc = fgwc)

  ## Prepare location annotations
  if (loc_annot != "none") {
    annotations_and_colours <- .int_getAnnotsAndColours(fgwc = fgwc,
                                                        loc_annot = loc_annot,
                                                        order_rows = order_rows)
  } else {
    annotations_and_colours <- list(annotations = NA, colours = NA)
  }

  ## Order data input by annotation or cluster
  if (order_rows == "none") {
    cluster_rows = TRUE
  } else {
    data_in <- data_in[rownames(annotations_and_colours$annotations), ]
    cluster_rows = FALSE
  }

  ## Create heatmap of Factor scores
  pheatmap(data_in,
           scale = "row",
           cluster_rows = cluster_rows,
           cluster_cols = TRUE,
           annotation_row = annotations_and_colours$annotations,
           annotation_colors = annotations_and_colours$colours,
           fontsize_row = 3,
           ...)
}


#' Plot FGWC NMF Metagene Heatmap
#'
#' This function generates a clustered heatmap of metagene signatures.
#' Essentially is visualising the gene scores obtained from NMF for each
#' signature.
#'
#' @param fgwc An object of class `fgwc` containing the results of FGWC
#' analysis.
#' @param ... Arguments passed to `pheatmap`.
#'
#' @returns A heatmap plot of factor scores with optional annotations.
#' @importFrom dplyr select contains all_of any_of mutate
#' @importFrom pheatmap pheatmap
#' @importFrom cols4all c4a
#'
#' @examples
#' \dontrun{
#' # Assuming `fgwc_object` is a valid FGWC object
#' plotFGWC_nmfMetagenesHeatmap(fgwc_object)
#' }
#'
#' @export
plotFGWC_nmfMetagenesHeatmap <- function(fgwc, ...) {
  ## Check fgwc argument is of class fgwc
  .int_checkFGWCClass(fgwc)

  ## Prepare data for heatmap
  data_in <- .int_getFactorData(fgwc = fgwc)

  ## Create heatmap of Metagene scores
  pheatmap(data_in,
           scale = "row",
           cluster_rows = TRUE,
           cluster_cols = TRUE,
           fontsize_row = 3,
           ...)
}


#' Plot Fuzzy Geographically Weighted Clustering (FGWC) - Pie and Donut Plot
#'
#' This function plots the FGWC using pie and donut plots. It visualises the
#' distribution of clusters, annotations or NMF factors for each location in
#' the spatial omics dataset. The function accepts several parameters to
#' customise the plot appearance and behaviour.
#'
#' @param fgwc Object of class \linkS4class{fgwc}. The Fuzzy Geographically
#' Weighted Clustering object, typically created by
#' \code{\link[STExplorer]{fgwcSTE}}.
#' @param m_sfe The spatial feature experiment (SFE) or metaSFE object.
#' @param sample_id A character vector. The sample ID. Defaults to NULL and
#' selects the fisrt sample if a metaSFE object is provided to the `m_sfe`
#' argument. If an SFE object is provided then this argument is omitted.
#' @param mapping A aesthetic mapping created by \code{\link[ggplot2]{aes}}. It
#' specifies how the data is mapped to the plot. The expected mappings are
#' "pie" and "donut" which determine the segmentation of the pie and donut
#' plots, respectively. The variables that can be supplied to those mappings
#' are currently one of `annotation`, `clustering`, and `factors`. The use of
#' the `annotation` assumes the existence of an `annotation` column in the
#' `colData`.
#' @param start Angle in radians at which the pie/donut plot starts.
#' @param addPieLabel A logical indicating whether to add labels to the pie plot
#'   segments.
#' @param addDonutLabel Logical indicating whether to add labels to the donut
#' plot segments.
#' @param showRatioDonut Logical indicating whether to show the ratio of each
#' donut segment to the whole.
#' @param showRatioPie Logical indicating whether to show the ratio of each pie
#'   segment to the whole.
#' @param ratioByGroup Logical indicating whether the ratio displayed on the
#' donut plot should be calculated by group or individually.
#' @param showRatioThreshold The minimum ratio required to display a segment
#' label in the pie or donut plot.
#' @param labelposition Position of the labels in the plot. It can take values
#' 0, 1, 2, where 0 places the labels outside the plot, 1 places them on the
#' segments, and 2 places them mostly outside with some overlapping.
#' @param labelpositionThreshold Threshold for the label position 2. Labels
#' with ratios below this threshold will be positioned outside the plot, while
#' others may overlap.
#' @param r0, @param r1, @param r2 Radii of the pie plot, inner donut plot, and
#' outer donut plot, respectively.
#' @param explode A numeric vector or NULL. If not NULL, the specified segments
#' in the pie plot will be exploded.
#' @param selected A numeric vector or NULL. If not NULL, the specified
#' segments in the donut plot will be exploded.
#' @param explodePos Position to which the exploded segments in the pie
#' or donut plots will be moved.
#' @param color The border colour of the pie and donut plots.
#' @param pieColours A character vector of colours to be used in the pie plot
#' segments. If not provided, colours are automatically generated.
#' @param pieAlpha Transparency of the pie plot segments.
#' @param donutAlpha Transparency of the donut plot segments.
#' @param maxx Maximum radius of the pie/donut plots. If not provided, it is
#'   determined automatically.
#' @param showPieName Logical indicating whether to display the name of the
#' pie plot.
#' @param showDonutName Logical indicating whether to display the name of
#' the donut plot.
#' @param title A character string to add as title above the donut plot.
#' If NULL, no title will be displayed.
#' @param pieLabelSize Size of the labels in the pie plot.
#' @param donutLabelSize Size of the labels in the donut plot.
#' @param titlesize Size of the title or plot names.
#' @param explodePie Logical indicating whether to explode the pie plot
#' segments at the positions specified by \code{explode}.
#' @param explodeDonut Logical indicating whether to explode the donut plot
#' segments at the positions specified by \code{selected}.
#' @param use.label Logical indicating whether to use the original labels from
#' the data for the pie and donut plots.
#' @param use.labels Logical indicating whether to use the original labels from
#' the data for the segment labels.
#' @param family The font family to use in the plot.
#'
#' @return A ggplot2 plot object.
#'
#' @importFrom ggplot2 ggplot aes scale_fill_manual theme geom_segment
#' @importFrom ggplot2 coord_fixed xlim ylim guides element_rect
#' @importFrom ggplot2 geom_text annotate element_text
#' @importFrom ggforce theme_no_axes geom_arc_bar
#' @importFrom dplyr group_by count rename select slice_max ungroup contains
#' @importFrom tidyr pivot_longer
#' @importFrom scales percent
#' @importFrom grid grid.newpage viewport
#'
#' @examples
#' \dontrun{
#' # Plot FGWC using default settings
#' plotFGWC_pie(fgwC_obj, m_sfe_obj)
#' }
#'
#' @export
plotFGWC_pie <- function(fgwc,
                         m_sfe,
                         sample_id = NULL,
                         mapping = aes(pie = cluster, donut = annotation),
                         start = 0,
                         addPieLabel = TRUE,
                         addDonutLabel = TRUE,
                         showRatioDonut = TRUE,
                         showRatioPie = TRUE,
                         ratioByGroup = TRUE,
                         showRatioThreshold = 0.02,
                         labelposition = 2,
                         labelpositionThreshold = 0.1,
                         r0 = 0.3,
                         r1 = 1,
                         r2 = 1.2,
                         explode = NULL,
                         selected = NULL,
                         explodePos = 0.1,
                         color = "white",
                         pieColours = NULL,
                         pieAlpha = 0.8,
                         donutAlpha = 1,
                         maxx = NULL,
                         showPieName = TRUE,
                         showDonutName = FALSE,
                         title = NULL,
                         pieLabelSize = 4,
                         donutLabelSize = 3,
                         titlesize = 5,
                         explodePie = TRUE,
                         explodeDonut = FALSE,
                         use.label = TRUE,
                         use.labels = TRUE,
                         family = "") {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Extract mapping names
  pies <- .int_getMapping(mapping, "pie")
  donuts <- .int_getMapping(mapping, "donut")

  ## Check that mappings provided are correct
  .int_checkMappings(mapping = mapping)

  ## Prepare data to plot
  data <- fgwc$finaldata %>%
    rownames_to_column(var = "Barcode")

  if (!"annotation" %in% colnames(data)) {
    annot <- colData(sfe)["annotation"] %>%
      as.data.frame() %>%
      rownames_to_column(var = "Barcode")

    data <- left_join(data, annot, by = "Barcode")
  }



  if ("factors" %in% c(pies, donuts)) {
    data <- tidyr::pivot_longer(data,
                                contains("Factor"),
                                names_to = "factors",
                                values_to = "factor_score") %>%
      group_by(Barcode) %>%
      dplyr::slice_max(order_by = factor_score) %>%
      dplyr::ungroup() %>%
      dplyr::select(-tidyr::all_of(c("factor_score", "Barcode")))
  }

  data <- data %>%
    dplyr::select(tidyr::all_of(c(pies, donuts)))

  ## Get colours
  if (is.null(pieColours)) {
    mainColours <- getColours(length(unique(data[[pies]])))
  } else {
    mainColours <- pieColours
  }

  ## The below code is from webr::PieDonut function. It is slightly modified,
  ## updated with the current ggplot2 usage rules, and reduced redundant steps.
  ## However, the main functionality is the same.

  # Calculate pie data
  df <- data %>%
    group_by(.data[[pies]]) %>%
    dplyr::count(.data[[pies]]) %>%
    dplyr::rename("Freq" = "n")
  colnames(df)[1] <- pies
  df$end <- cumsum(df$Freq)
  df$start <- dplyr::lag(df$end)
  df$start[1] <- 0
  total <- sum(df$Freq)
  df$start1 <- df$start * 2 * pi/total
  df$end1 <- df$end * 2 * pi/total
  df$start1 <- df$start1 + start
  df$end1 <- df$end1 + start
  df$focus <- 0
  if (explodePie) {
    df$focus[explode] <- explodePos
  }
  df$mid <- (df$start1 + df$end1)/2
  df$x <- ifelse(df$focus == 0, 0, df$focus * sin(df$mid))
  df$y <- ifelse(df$focus == 0, 0, df$focus * cos(df$mid))
  df$label <- df[[pies]]
  df$ratio <- df$Freq/sum(df$Freq)
  if (showRatioPie) {
    df$label <- ifelse(df$ratio >= showRatioThreshold,
                       paste0(df$label, "\n(", scales::percent(df$ratio), ")"),
                       as.character(df$label))
  }
  df$labelx <- (r0 + r1)/2 * sin(df$mid) + df$x
  df$labely <- (r0 + r1)/2 * cos(df$mid) + df$y
  df[[pies]] <- factor(df[[pies]])

  # Calculate donut data
  if (!is.null(donuts)) {
    df3 <- data.frame(table(data[[donuts]], data[[pies]]),
                      stringsAsFactors = FALSE)
    colnames(df3)[1:2] <- c(donuts, pies)
    a <- table(data[[donuts]], data[[pies]])
    df3$group <- rep(colSums(a), each = nrow(a))
    df3$pie <- rep(1:ncol(a), each = nrow(a))
    total <- sum(df3$Freq)
    df3$ratio1 <- df3$Freq/total
    if (ratioByGroup) {
      df3$ratio <- scales::percent(df3$Freq/df3$group)
    } else {
      df3$ratio <- scales::percent(df3$ratio1)
    }
    df3$end <- cumsum(df3$Freq)
    df3$start <- dplyr::lag(df3$end)
    df3$start[1] <- 0
    df3$start1 <- df3$start * 2 * pi/total
    df3$end1 <- df3$end * 2 * pi/total
    df3$start1 <- df3$start1 + start
    df3$end1 <- df3$end1 + start
    df3$mid <- (df3$start1 + df3$end1)/2
    df3$focus <- 0
    if (!is.null(selected)) {
      df3$focus[selected] <- explodePos
    } else if (!is.null(explode)) {
      selected <- c()
      for (i in 1:length(explode)) {
        start <- 1 + nrow(a) * (explode[i] - 1)
        selected <- c(selected, start:(start + nrow(a) - 1))
      }
      df3$focus[selected] <- explodePos
    }
    df3$x <- 0
    df3$y <- 0
    if (!is.null(explode)) {
      for (i in 1:length(explode)) {
        xpos <- df$focus[explode[i]] * sin(df$mid[explode[i]])
        ypos <- df$focus[explode[i]] * cos(df$mid[explode[i]])
        df3$x[df3$pie == explode[i]] <- xpos
        df3$y[df3$pie == explode[i]] <- ypos
      }
    }
    df3$no <- 1:nrow(df3)
    df3$label <- df3[[donuts]]
    if (showRatioDonut) {
      maxLabelSize <- max(nchar(levels(df3$label)))
      if (maxLabelSize <= 2) {
        df3$label <- paste0(df3$label, "(", df3$ratio, ")")
      } else {
        df3$label <- paste0(df3$label, "\n(", df3$ratio, ")")
      }
    }
    df3$label[df3$ratio1 == 0] <- ""
    df3$label[df3$ratio1 < showRatioThreshold] <- ""
    df3$hjust <- ifelse((df3$mid %% (2 * pi)) > pi, 1, 0)
    df3$vjust <- ifelse(((df3$mid %% (2 * pi)) < (pi/2)) |
                          (df3$mid %% (2 * pi) > (pi * 3/2)),
                        0,
                        1)
    df3$no <- factor(df3$no)

    # Prepare label positions for donuts
    if (labelposition > 0) {
      df3$radius <- r2
      if (explodeDonut) {
        df3$radius[df3$focus != 0] <- df3$radius[df3$focus != 0] + df3$focus[df3$focus != 0]
      }
      df3$segx <- df3$radius * sin(df3$mid) + df3$x
      df3$segy <- df3$radius * cos(df3$mid) + df3$y
      df3$segxend <- (df3$radius + 0.05) * sin(df3$mid) + df3$x
      df3$segyend <- (df3$radius + 0.05) * cos(df3$mid) + df3$y
      if (labelposition == 2) {
        df3$radius <- (r1 + r2)/2
      }
      df3$labelx <- (df3$radius) * sin(df3$mid) + df3$x
      df3$labely <- (df3$radius) * cos(df3$mid) + df3$y
    } else {
      df3$radius <- (r1 + r2)/2
      if (explodeDonut) {
        df3$radius[df3$focus != 0] <- df3$radius[df3$focus != 0] + df3$focus[df3$focus != 0]
      }
      df3$labelx <- df3$radius * sin(df3$mid) + df3$x
      df3$labely <- df3$radius * cos(df3$mid) + df3$y
    }
    df3$segx[df3$ratio1 == 0] <- 0
    df3$segxend[df3$ratio1 == 0] <- 0
    df3$segy[df3$ratio1 == 0] <- 0
    df3$segyend[df3$ratio1 == 0] <- 0
    if (labelposition == 0) {
      df3$segx[df3$ratio1 < showRatioThreshold] <- 0
      df3$segxend[df3$ratio1 < showRatioThreshold] <- 0
      df3$segy[df3$ratio1 < showRatioThreshold] <- 0
      df3$segyend[df3$ratio1 < showRatioThreshold] <- 0
    }

    ## Get colours for doughnut
    subCol_no <- length(unique(df3[[donuts]]))
    subColours <- getGradients(mainColours, subCol_no)
    del <- which(df3$Freq == 0)
    if (length(del) > 0) {
      subColours <- subColours[-del]
    }
  }

  # Prepare plot
  p <- ggplot() + ggforce::theme_no_axes() + coord_fixed()
  r3 <- ifelse(is.null(maxx), r2 + 0.3, maxx)

  # Create pie plot
  p1 <- p +
    ggforce::geom_arc_bar(data = df,
                          aes(x0 = x, y0 = y, r0 = r0, r = r1, start = start1,
                              end = end1, fill = cluster),
                          alpha = pieAlpha,
                          color = color) +
    theme(rect = element_rect(fill = "transparent",
                                                linewidth = 0),
                   panel.background = element_rect(fill = "transparent"),
                   panel.border = element_rect(linewidth = 0),
                   panel.grid.major = element_blank(),
                   panel.grid.minor = element_blank()) +
    scale_fill_manual(values = mainColours) +
    xlim(r3 * c(-1, 1)) +
    ylim(r3 * c(-1, 1)) +
    guides(fill = "none")

  # Add pie labels
  if ((labelposition == 1) & (is.null(donuts))) {
    p1 <- p1 +
      geom_segment(data = df,
                   aes(x = segx, y = segy, xend = segxend, yend = segyend)) +
      geom_text(data = df,
                aes(x = segxend, y = segyend, label = label,
                    hjust = hjust, vjust = vjust),
                size = pieLabelSize,
                family = family)

  } else if ((labelposition == 2) & (is.null(donuts))) {
    p1 <- p1 +
      geom_segment(data = df[df$ratio < labelpositionThreshold, ],
                   aes(x = segx, y = segy, xend = segxend, yend = segyend)) +
      geom_text(data = df[df$ratio < labelpositionThreshold, ],
                aes(x = segxend, y = segyend, label = label,
                    hjust = hjust, vjust = vjust),
                size = pieLabelSize,
                family = family) +
      geom_text(data = df[df$ratio >= labelpositionThreshold, ],
                aes(x = labelx, y = labely, label = label),
                size = pieLabelSize,
                family = family)

  } else {
    p1 <- p1 +
      geom_text(data = df,
                aes(x = labelx, y = labely, label = label),
                size = pieLabelSize,
                family = family)
  }

  # Add pie name
  if (showPieName) {
    p1 <- p1 +
      annotate("text",
               x = 0,
               y = 0,
               label = pies,
               size = titlesize,
               family = family)
  }

  # Adjust theme
  p1 <- p1 + theme(text = element_text(family = family))

  # Create donut plot
  if (!is.null(donuts)) {
    if (explodeDonut) {
      p3 <- p +
        ggforce::geom_arc_bar(data = df3,
                              aes(x0 = x, y0 = y, r0 = r1, r = r2,
                                  start = start1, end = end1,
                                  fill = no, explode = focus),
                              alpha = donutAlpha,
                              color = color)

    } else {
      p3 <- p +
        ggforce::geom_arc_bar(data = df3,
                              aes(x0 = x, y0 = y, r0 = r1, r = r2,
                                  start = start1, end = end1,
                                  fill = no),
                              alpha = donutAlpha,
                              color = color)

    }
    p3 <- p3 +
      theme(rect = element_rect(fill = "transparent", linewidth = 0),
            panel.background = element_rect(fill = "transparent"),
            panel.border = element_rect(linewidth = 0),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank()) +
      scale_fill_manual(values = subColours) +
      xlim(r3 * c(-1, 1)) +
      ylim(r3 * c(-1, 1)) +
      guides(fill = "none")

    # Add donut labels
    if (labelposition == 1) {
      p3 <- p3 +
        geom_segment(data = df3,
                     aes(x = segx, y = segy, xend = segxend, yend = segyend)) +
        geom_text(data = df3,
                  aes(x = segxend, y = segyend, label = label,
                      hjust = hjust, vjust = vjust),
                  size = donutLabelSize,
                  family = family)

    } else if (labelposition == 0) {
      p3 <- p3 +
        geom_text(data = df3,
                  aes(x = labelx, y = labely, label = label),
                  size = donutLabelSize,
                  family = family)

    } else {
      p3 <- p3 +
        geom_segment(data = df3[df3$ratio1 < labelpositionThreshold, ],
                     aes(x = segx, y = segy, xend = segxend, yend = segyend)) +
        geom_text(data = df3[df3$ratio1 < labelpositionThreshold, ],
                  aes(x = segxend, y = segyend, label = label,
                      hjust = hjust, vjust = vjust),
                  size = donutLabelSize,
                  family = family) +
        geom_text(data = df3[df3$ratio1 >= labelpositionThreshold, ],
                  aes(x = labelx, y = labely, label = label),
                  size = donutLabelSize,
                  family = family)
    }

    # Add title or donut name
    if (!is.null(title)) {
      p3 <- p3 +
        annotate("text",
                 x = 0,
                 y = r3,
                 label = title,
                 size = titlesize,
                 family = family)

    } else if (showDonutName) {
      p3 <- p3 +
        annotate("text",
                 x = (-1) * r3,
                 y = r3,
                 label = donuts,
                 hjust = 0,
                 size = titlesize,
                 family = family)
    }

    # Adjust theme
    p3 <- p3 + theme(text = element_text(family = family))

    # Combine plots
    grid::grid.newpage()
    print(p1, vp = grid::viewport(height = 1, width = 1))
    print(p3, vp = grid::viewport(height = 1, width = 1))
  } else {
    p1
  }
}



#' Plot Heatmap for Fuzzy Geographically Weighted Clustering (FGWC)
#'
#' This function plots a heatmap for the gene expression of marker genes for a
#' specific cluster.
#'
#' @param fgwc The result of FGWC clustering.
#' @param m_sfe The spatial feature experiment (SFE) or metaSFE object.
#' @param sample_id The sample ID.
#' @param markers A data frame with 4 columns: gene.name, ensg.ID, Type,
#' and Subtype.
#' @param cluster_no The cluster number for which the heatmap is generated.
#' @param cutree_cols Optional, cutree result for columns.
#'
#' @return A pheatmap object.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' fgwc_result <- fgwc_nmf(m_sfe, sample_id, top_hvgs, ncomponents = 2,
#' ntop = 600)
#'
#' markers_data <- read.csv("markers_data.csv") # Provide your markers data
#' cluster_no <- 1 # Provide the cluster number for which heatmap is desired
#'
#' plotFGWC_markersHeatmap(fgwc_result, m_sfe, sample_id, markers_data, cluster_no)
#' }
#'
#' @seealso
#' \code{\link{fgwc_nmf}}, \code{\link{plotFGWC_single}},
#' \code{\link{plotFGWC_multi}}
#'
#' @details
#' Additional details about the function or its behaviour can be added here.
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @keywords clustering fuzzy-logic spatial heatmap visualization fgwc
#' @family plotting functions
#' @rdname plotFGWC_markersHeatmap
#' @aliases plotFGWC_markersHeatmap
#'
#' @importFrom grDevices colorRampPalette
#'
#' @export
plotFGWC_markersHeatmap <- function(fgwc,
                             m_sfe,
                             sample_id,
                             markers,
                             cluster_no,
                             cutree_cols = NA) {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## 'markers' argument should be a data frame with 4 columns: gene.name,
  ##  ensg.ID, Type, and Subtype
  if (length(markers) == 0) {
    stop("The 'markers' argument is empty.",
         " Please provide a 4-column data frame.",
         "\n If in doubt what the data frame should include, look at the ",
         "format section of the markers example dataset typing ?markers")
  }

  ## Prepare expression data for heatmap
  markers <- .int_markers(markers = markers)
  marker_counts <- .int_fgwcMarkerCounts(sfe = sfe, markers = markers)

  ## Add clusters to gene counts
  marker_clusts <- data.frame("cluster" = fgwc$cluster,
                              marker_counts)

  ## Prepare pheatmap input
  pheat_in <- .int_pheatInput(marker_clusts = marker_clusts,
                              cluster_no = cluster_no,
                              markers = markers)

  ## Heatmap
  ## Annotate rows
  annot_row <- data.frame(Type = markers$Type, # get annotations
                          Subtype = markers$Subtype)
  rownames(annot_row) <- make.unique(markers$gene.name) # add gene names in rownames
  ## Remove genes that might not be present in the input
  annot_row <- annot_row %>%
    filter(rownames(.) %in% rownames(pheat_in)) %>%
    arrange(.data[["Type"]])
  col_type <- length(unique(markers$Type))
  col_subT <- length(unique(markers$Subtype))
  annot_colours <- list(Type = getColours(col_type),
                        Subtype = c4a(palette = "carto.pastel", n = col_subT))
  names(annot_colours$Type) <- unique(markers$Type)
  names(annot_colours$Subtype) <-  unique(markers$Subtype)

  ## group rows
  gaps_row <- utils::head(as.numeric(cumsum(table(annot_row$Type))), -1)

  ## Heatmap colour and set it around zero
  paletteLength <- 25
  c4a_palette <- c4a(palette = "tol.sunset")[c(1,5,9)]
  ph.color <- colorRampPalette(c(c4a_palette[1],
                                 "white",
                                 c4a_palette[3]))(paletteLength)
  ph.breaks <- c(seq(min(pheat_in),
                     0,
                     length.out = ceiling(paletteLength/2) + 1),
                 seq(max(pheat_in)/paletteLength,
                     max(pheat_in),
                     length.out = floor(paletteLength/2)))

  ## Plot heatmap
  heatmap <- pheatmap(pheat_in,
                      color = ph.color,
                      breaks = ph.breaks,
                      annotation_colors = annot_colours,
                      annotation_row = annot_row,
                      gaps_row = gaps_row,
                      show_colnames = FALSE,
                      cluster_rows = FALSE,
                      cluster_cols = TRUE,
                      cutree_cols = cutree_cols,
                      main = paste0("Cluster ", cluster_no))

  return(heatmap)
}


#' Plot FGWC Sub-Clusters in Map
#'
#' This function generates a map of sub-clusters based on the fuzzy
#' geographically weighted clustering (FGWC) results.
#'
#' @param heatmap The FGWC heatmap object.
#' @param k The number of sub-clusters.
#' @param clust The main cluster number.
#' @param m_sfe Either a SpatialfeatureExperiment or a
#' SpatialfeatureExperiment object containing spatial transcriptomics data.
#' @param sample_id The sample.
#' @param annot_cols Vector of colours for ground truth annotations. If NULL,
#' colours are assigned automatically.
#' @param subClust_cols Vector of colours for sub-clusters. If NULL, colours are
#'  generated automatically.
#'
#' @return A ggplot object visualizing the sub-clusters in the spatial context.
#'
#' @details
#' This function takes the results of the FGWC clustering and produces a spatial
#'  map of sub-clusters for a specific FGWC cluster. It overlays the identified
#'  sub-clusters on top of the original spatial features, allowing users to
#'  visualise the distribution of sub-clusters within the main cluster areas.
#'
#' @importFrom sf st_polygon
#' @importFrom ggplot2 scale_colour_manual
#'
#' @examples
#' \dontrun{
#' # Plot sub-clusters with default colors.
#' plotFGWC_subClust(heatmap, k = 5, clust = 3, m_sfe, sample_id = "JBO019")
#'
#' # Plot sub-clusters with custom colors.
#' plotFGWC_subClust(heatmap, k = 5, clust = 3, m_sfe, sample_id = "JBO019",
#'                   annot_cols = c("red", "blue"),
#'                   subClust_cols = c("orange","green","yellow","red","blue"))
#' }
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @export
plotFGWC_subClust <- function(heatmap, k, clust,
                              m_sfe, sample_id,
                              annot_cols = NULL, subClust_cols = NULL) {
  ## Plot sub-clusters in map

  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Extracting sub-clusters
  subclusts <- .int_getSubClusts(heatmap = heatmap, k = k)

  ## Extracting necessary information
  sfe_data <- colData(sfe)
  spot_hex_geometry <- colGeometry(sfe, "spotHex")

  ## Creating sub-cluster map
  subclust_map <- data.frame(
    Barcode = rownames(sfe_data),
    geometry = spot_hex_geometry,
    gTruth = sfe_data$annotation,
    geometry_subC = spot_hex_geometry
  ) %>%
    dplyr::left_join(subclusts, by = "Barcode") %>%
    dplyr::mutate(
      subclust = ifelse(.data$subclust > 0,
                        paste0(clust, LETTERS[.data$subclust]),
                        NA)
    ) %>%
    rename("geometry_subC" = "geometry.1")
  subclust_map$geometry_subC[is.na(subclust_map$subclust)] <- st_polygon()

  ## Extract colours
  if (is.null(annot_cols)) {
    colNo1 <- .int_getLabelsNo(subclust_map$gTruth)
    colour.annot <- getColours(colNo1)
  } else {
    colour.annot <- annot_cols
  }
  if (is.null(subClust_cols)) {
    colNo2 <- .int_getLabelsNo(subclust_map$subclust)
    colour.subClust <- .int_getColSubset(colNo1, colNo2)
  } else {
    colour.subClust <- subClust_cols
  }

  ggplot(data = subclust_map) +
    geom_sf(aes(geometry = geometry, fill = gTruth),
            alpha = 0.8) +
    geom_sf(aes(geometry = geometry_subC, colour = subclust),
            fill = NA,
            linewidth = 1.1) +
    scale_fill_manual(values = colour.annot,
                      na.value = "grey95") +
    scale_colour_manual(values = colour.subClust,
                        na.value = "grey95") +
    labs(title = paste0("Cluster ", clust),
         fill = "Ground\nTruth",
         colour = "Sub-clusters") +
    theme_void()
}


#' Plot an FGWC Sub-Cluster Heatmap of gene expression
#'
#' This function generates a heatmap for the gene expression profiles within a
#' specific sub-cluster identified by fuzzy geographically weighted clustering
#' (FGWC).
#'
#' @param heatmap The FGWC heatmap object.
#' @param k The number of sub-clusters used in FGWC.
#' @param markers A data frame with gene markers information, including columns
#' "gene.name", "ensg.ID"  "Type", and "Subtype".
#' @param m_sfe Either a a SpatialfeatureExperiment or a
#' SpatialfeatureExperiment object containing spatial transcriptomics data.
#' @param sample_id The sample ID used for FGWC.
#' @param cluster_no The specific sub-cluster number for which the heatmap is
#' generated.
#' @param cutree_cols Number of columns for cutree to cut the sample tree of the
#'  heatmap. If NA, the tree will not be cut.
#'
#' @return A pheatmap object representing the gene expression heatmap for the
#' specified sub-cluster.
#'
#' @details
#' This function takes the results of the FGWC clustering, extracts the gene
#' expression profiles within the specified sub-cluster, and generates a
#' heatmap. The heatmap provides insights into the expression patterns of
#' selected markers within the identified sub-cluster.
#'
#' @examples
#' \dontrun{
#' # Plot a heatmap for sub-cluster 3 using default colors.
#' plotFGWC_subHeatmap(heatmap, k = 5, markers, m_sfe, sample_id = "JBO019",
#' cluster_no = 3)
#'
#' # Plot a heatmap for sub-cluster 2 with custom cutree colors.
#' plotFGWC_subHeatmap(heatmap, k = 5, markers, m_sfe, sample_id = "JBO019",
#' cluster_no = 2, cutree_cols = 4)
#' }
#'
#' @export
plotFGWC_subHeatmap <- function(heatmap,
                                k,
                                markers,
                                m_sfe,
                                sample_id,
                                cluster_no,
                                cutree_cols = NA) {
  ## Check SFE or MSFE?
  sfe <- .int_sfeORmsfe(m_sfe = m_sfe, sample_id = sample_id)

  ## Extracting sub-clusters
  subclusts <- .int_getSubClusts(heatmap = heatmap, k = k)

  ## Prepare expression data for heatmap
  markers <- .int_markers(markers = markers)
  marker_counts <- .int_fgwcMarkerCounts(sfe = sfe, markers = markers) %>%
    rownames_to_column(var = "Barcode")

  ## Add clusters to gene counts
  marker_clusts <- left_join(subclusts, marker_counts, by = "Barcode") %>%
    column_to_rownames(var = "Barcode")

  ## Prepare pheatmap input
  pheat_in <- .int_pheatInput(marker_clusts = marker_clusts,
                              cluster_no = cluster_no,
                              markers = markers)

  ## Heatmap
  ## Annotate rows
  annot_row <- data.frame(Type = markers$Type, # get annotations
                          Subtype = markers$Subtype)
  rownames(annot_row) <- markers$gene.name # add gene names in rownames
  ## Remove genes that might not be present in the input
  annot_row <- annot_row %>%
    filter(rownames(.) %in% rownames(pheat_in)) %>%
    arrange(.data$Type)
  col_type <- length(unique(markers$Type))
  col_subT <- length(unique(markers$Subtype))
  annot_colours <- list(Type = getColours(col_type),
                        Subtype = c4a(palette = "carto.pastel", n = col_subT))
  names(annot_colours$Type) <- unique(markers$Type)
  names(annot_colours$Subtype) <-  unique(markers$Subtype)

  ## group rows
  gaps_row <- utils::head(as.numeric(cumsum(table(annot_row$Type))), -1)

  ## Heatmap colour and set it around zero
  paletteLength <- 25
  c4a_palette <- c4a(palette = "tol.sunset")[c(1,5,9)]
  ph.color <- colorRampPalette(c(c4a_palette[1],
                                 "white",
                                 c4a_palette[3]))(paletteLength)
  ph.breaks <- c(seq(min(pheat_in),
                     0,
                     length.out = ceiling(paletteLength/2) + 1),
                 seq(max(pheat_in)/paletteLength,
                     max(pheat_in),
                     length.out = floor(paletteLength/2)))

  ## Plot heatmap
  heatmap <- pheatmap(pheat_in,
                      color = ph.color,
                      breaks = ph.breaks,
                      annotation_colors = annot_colours,
                      annotation_row = annot_row,
                      gaps_row = gaps_row,
                      show_colnames = FALSE,
                      cluster_rows = FALSE,
                      cluster_cols = TRUE,
                      cutree_cols = cutree_cols,
                      main = paste0("Sub-Cluster ", cluster_no))

  return(heatmap)
}


# ---------------------------------------------------------------------------- #
#  ############## INTERNAL FUNCTIONS ASSOCIATED WITH THE FGWC ###############
# ---------------------------------------------------------------------------- #
#' Internal Function: Generate Data for FGWC Plot
#'
#' This function generates data suitable for plotting FFGWC results.
#'
#' @param fgwc An object containing FGWC results, typically obtained from the
#' `fgwcSTE` function.
#' @param sfe A SpatialFeatureExperiment object containing spatial coordinates
#' and features.
#' @param mode Character, indicating the mode for generating plot data. Options
#' are "single" (default) for a single-cluster mode or "multi" for a
#' multi-cluster mode.
#'
#' @return A data frame containing information for generating FGWC plots. In
#' single-cluster mode, the data frame includes cluster information for each
#' spot. In multi-cluster mode, the entire data frame is returned.
#'
#' @details The function generates data suitable for plotting FGWC results. In
#' single-cluster mode, the data frame includes cluster information for each
#' spot. In multi-cluster mode, the entire data frame is returned. The mode is
#' specified using the 'mode' argument.
#'
#' @seealso \code{\link[SpatialFeatureExperiment]{colGeometry}},
#' \code{\link[SpatialFeatureExperiment]{colData}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords FGWC, clustering, spatial coordinates
#'
#' @rdname dot-int_fgwcPlotDataMap
#'
.int_fgwcPlotDataMap <- function(fgwc, sfe, mode = c("single", "multi")) {
  clusts.number <- 1:ncol(fgwc$membership)
  fgwc_membership <- data.frame(fgwc$membership)
  colnames(fgwc_membership) <- paste0("Cluster_", clusts.number)
  rownames(fgwc_membership) <- colnames(sfe)
  fgwc_membership <- data.frame(fgwc_membership,
                                geometry = colGeometry(sfe, "spotHex"))
  if (mode == "single") {
    fgwc_membership$Cluster <- fgwc$cluster
  } else if (mode == "multi") {
    return(fgwc_membership)
  } else if (mode == "both") {

  } else {
    stop("\n'mode' argument accepts only 'single' or 'multi' as values.\n")
  }

  return(fgwc_membership)
}


#' Internal Function: Generate Data for FGWC Violin Plot
#'
#' This function generates data suitable for plotting FFGWC results as violins.
#'
#' @param fgwc An object containing FGWC results, typically obtained from the
#' `fgwcSTE` function.
#' @param sfe A SpatialFeatureExperiment object containing spatial coordinates
#' and features.
#'
#' @return A data frame containing information for generating FGWC plots. In
#' single-cluster mode, the data frame includes cluster information for each
#' spot. In multi-cluster mode, the entire data frame is returned.
#'
#' @details The function generates data suitable for plotting FGWC results as
#' violin plots.
#'
#' @seealso \code{\link[SpatialFeatureExperiment]{colGeometry}},
#' \code{\link[SpatialFeatureExperiment]{colData}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords FGWC, clustering, spatial coordinates
#'
#' @rdname dot-int_fgwcPlotDataViolin
#'
.int_fgwcPlotDataViolin <- function(fgwc, sfe) {
  clusts.number <- 1:ncol(fgwc$membership)
  fgwc_membership <- data.frame(fgwc$membership)
  colnames(fgwc_membership) <- paste0("Cluster_", clusts.number)
  rownames(fgwc_membership) <- colnames(sfe)
  fgwc_membership <- data.frame(fgwc_membership,
                                Cluster = fgwc$cluster)
  if (!is.null(colData(sfe)[["annotation"]])) {
    fgwc_membership$annotation = colData(sfe)$annotation
  } else {
    fgwc_membership <- fgwc_membership %>%
      mutate(annotation = Cluster)
  }

  return(fgwc_membership)
}


#' Internal Function: generate data for NMF factor scores
#'
#' This function generates data suitable for plotting FFGWC results as violins.
#'
#' @param nmf An object containing NMF results, typically obtained from the
#' `fgwc_nmf` function.
#' @param sfe A SpatialFeatureExperiment object containing spatial coordinates
#' and features.
#'
#' @return A data frame containing information for generating NMF plots.
#'
#' @details The function generates data suitable for plotting NMF results as
#' map.
#'
#' @seealso \code{\link[SpatialFeatureExperiment]{colGeometry}},
#' \code{\link[SpatialFeatureExperiment]{colData}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords FGWC, clustering, spatial coordinates
#'
#' @rdname dot-int_nmfPlotDataMap
#'
.int_nmfPlotDataMap <- function(nmf, sfe) {
  scores <- (nmf) %>%
    as.data.frame() %>%
    rownames_to_column()

  geoms <- colGeometry(sfe, "spotHex") %>%
    rownames_to_column()

  # Combine spatial coordinates with scores
  scores <- dplyr::left_join(geoms, scores, by = "rowname") %>%
    column_to_rownames() %>%
    pivot_longer(cols = -geometry, names_to = "Factors", values_to = "score")

  return(scores)
}


#' Internal Function: Retrieve Normalised Counts for gene Markers
#'
#' This function retrieves normalised counts for a specified set of gene
#' markers from a SpatialFeatureExperiment object.
#'
#' @param sfe A SpatialFeatureExperiment object containing normalised counts.
#' @param markers A data frame containing information about FGWC markers,
#' including gene names and corresponding ENSG.IDs.
#'
#' @return A data frame with normalised counts for the specified FGWC markers.
#'
#' @details The function extracts normalised counts for a set of FGWC markers
#' from the provided SpatialFeatureExperiment object. It filters the counts
#' based on the ENSG.IDs of the specified markers, rearranges columns for
#' better readability, and provides a data frame with gene names as row names
#' and observations as variables.
#'
#' @seealso \code{\link[SpatialFeatureExperiment]{colData}},
#' \code{\link{as.data.frame}}, \code{\link[dplyr]{filter}},
#' \code{\link[dplyr]{left_join}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords FGWC, normalised counts, markers, SpatialFeatureExperiment
#'
#' @rdname dot-int_fgwcMarkerCounts
#'
.int_fgwcMarkerCounts <- function(sfe, markers) {
  ## Get normalised counts
  counts <- assay(sfe, "logcounts") %>%
    as(., "matrix") %>%
    as.data.frame() %>%
    ## Get Genes Of Interest (GOI)
    dplyr::filter(rownames(.) %in% markers$ensg.ID) %>%
    ## Get GOI ENSG.IDs to a column
    tibble::rownames_to_column(var = "ensg.ID") %>%
    ## Join with annotations
    dplyr::left_join(.,
                     markers[,c("gene.name", "ensg.ID")],
                     by = dplyr::join_by("ensg.ID")) %>%
    ## Remove ENSG.IDs
    dplyr::select(-"ensg.ID") %>%
    ## Bring gene names column to the front
    dplyr::relocate("gene.name") %>%
    ## Populate rownames with gene names
    tibble::column_to_rownames("gene.name") %>%
    ## Transpose to make it observation x variable
    t() %>%
    as.data.frame()

  return(counts)
}


#' Internal Function: Prepare Input Data for Plotting a Heatmap with Feature
#' Grouping
#'
#' This function prepares input data for plotting a heatmap with feature
#' grouping based on cluster or subcluster results.
#'
#' @param marker_clusts A data frame containing information about marker genes
#' and their cluster assignments.
#' @param cluster_no Numeric, the cluster or subcluster number for which to
#' prepare the input data.
#' @param markers A data frame containing information about FGWC markers,
#' including gene names.
#'
#' @return A scaled and ordered data frame suitable for generating a heatmap
#' with cell type.
#'
#' @details The function extracts information about marker genes and their
#' cluster or subcluster assignments from the provided data frame. It scales
#' the data, sets NaN values to zero, orders the data based on FGWC marker
#' genes, and drops any introduced NAs, resulting in a data frame ready for
#' plotting a heatmap with cell type.
#'
#' @seealso \code{\link{scale}}, \code{\link[dplyr]{filter}},
#' \code{\link[dplyr]{select}}, \code{\link[tidyr]{drop_na}}
#'
#' @importFrom tidyr drop_na
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords heatmap, cell type, clustering
#'
#' @rdname dot-int_pheatInput
#'
.int_pheatInput <- function(marker_clusts, cluster_no, markers) {
  ## Check for clusters or subclusters
  if ("cluster" %in% colnames(marker_clusts)) {
    input <- marker_clusts %>%
      dplyr::filter(.data$cluster == cluster_no) %>%
      dplyr::select(-all_of("cluster"))
  } else if ("subclust" %in% colnames(marker_clusts)) {
    input <- marker_clusts %>%
      dplyr::filter(.data$subclust == cluster_no) %>%
      dplyr::select(-all_of("subclust"))
  }

  ## Proceed with scaling and further wrangling
  input <- input %>%
    scale() %>%
    t() %>%
    as.data.frame()

  ## Set NaN values into zeros
  input[is.na(input)] <- 0

  ## Order and drop NAs introduced
  input <- input %>%
    .[markers$gene.name,] %>%
    tidyr::drop_na()

  return(input)
}


#' Process cell type Markers
#'
#' This function processes cell type markers, ensuring required column
#' names, arranging by marker types, and removing duplicates.
#'
#' @param markers A data frame containing information about cell type
#' markers, including gene names and types.
#'
#' @return A processed data frame with validated column names, arranged by
#' marker types, and duplicates removed.
#'
#' @details The function validates the column names of the input data frame,
#' ensuring the presence of "gene.name," "ensg.ID," "Type," and "Subtype"
#' columns. It arranges the markers by types and removes duplicate entries
#' based on ENSG.IDs, resulting in a processed data frame ready for further
#' analysis.
#'
#' @seealso \code{\link{.int_validateColumnNames}},
#' \code{\link{.int_arrangeByType}}, \code{\link{.int_removeDuplicates}}
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords cell type, markers, validation, duplicates
#'
#' @rdname dot-int_markers
#'
.int_markers <- function(markers) {
  .int_validateColumnNames(markers,
                           c("gene.name", "ensg.ID", "Type", "Subtype"))

  markers <- .int_arrangeByType(markers)
  markers <- .int_removeDuplicates(markers, "ensg.ID")

  return(markers)
}


#' Validate Column Names in a Data Frame
#'
#' This function validates the column names in a data frame, ensuring they
#' match the expected column names.
#'
#' @param df A data frame to validate.
#' @param expected_columns A character vector specifying the expected column
#' names.
#'
#' @return NULL if validation is successful; otherwise, an error is raised.
#'
#' @details The function checks if the actual column names in the provided data
#' frame match the expected column names. If there is a mismatch, it raises an
#' error indicating the expected and actual column names for user correction.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords validation, data frame, column names
#'
#' @rdname dot-int_validateColumnNames
#'
.int_validateColumnNames <- function(df, expected_columns) {
  actual_columns <- colnames(df)
  if (!all(actual_columns %in% expected_columns) ||
      length(actual_columns) != length(expected_columns)) {
    stop("Invalid column names. Expected: ",
         paste(expected_columns, collapse = ", "),
         "; Actual: ",
         paste(actual_columns, collapse = ", "))
  }
}


#' Arrange cell type Markers by Type
#'
#' This function arranges cell type markers by their types in
#' ascending order.
#'
#' @param markers A data frame containing information about cell type
#' markers, including gene names and types.
#'
#' @return A data frame with markers arranged by their types in ascending order.
#'
#' @details The function uses the `dplyr::arrange` function to sort the markers
#' based on the cell types in ascending order, resulting in a data frame where
#' markers are organised by their types for improved readability.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords cell type, markers, arrangement, types
#'
#' @rdname dot-int_arrangeByType
#'
.int_arrangeByType <- function(markers) {
  markers <- markers %>%
    dplyr::arrange(.data$Type)

  return(markers)
}


#' Remove Duplicates from cell type Markers
#'
#' This function removes duplicate entries from cell type markers based
#' on a specified column.
#'
#' @param markers A data frame containing information about cell type
#' markers, including gene names and types.
#' @param column The column based on which duplicates are identified
#' and removed.
#'
#' @return A data frame with duplicate entries removed based on the specified
#' column.
#'
#' @details The function uses the `BiocGenerics::duplicated` function to
#' identify and tag duplicate entries in the specified column. It then filters
#' out those entries, resulting in a data frame with unique cell type
#' markers based on the chosen column.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords cell type, markers, duplicates, removal
#'
#' @importFrom BiocGenerics duplicated
#'
#' @rdname dot-int_removeDuplicates
#'
.int_removeDuplicates <- function(markers, column) {
  markers <- markers %>%
    dplyr::mutate(dups = BiocGenerics::duplicated({{ column }})) %>%
    dplyr::filter(!.data$dups)

  return(markers)
}


#' Get the Number of Unique Labels in a Vector
#'
#' This function calculates the number of unique labels in a vector, excluding
#' missing values.
#'
#' @param vector A vector for which to calculate the number of unique labels.
#'
#' @return An integer representing the number of unique labels in the vector.
#'
#' @details The function utilises the `unique` function to extract unique l
#' abels from the vector. It then counts the non-missing labels and returns the
#' total number.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords unique labels, vector, counting
#'
#' @rdname dot-int_getLabelsNo
#'
.int_getLabelsNo <- function(vector) {
  labels <- unique(vector)
  out <- sum(!is.na(labels))

  return(out)
}


#' Get a Subset of Colours from a Palette
#'
#' This function retrieves a subset of colours from a palette based on
#' specified indices.
#'
#' @param no1 The starting index for the subset.
#' @param no2 The ending index for the subset.
#'
#' @return A vector of colours representing the subset from the palette.
#'
#' @details The function uses the `getColours` function to obtain a palette of
#' colours. It then extracts a subset of colours starting from the specified
#' index `no2` up to the end of the palette.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @keywords subset, colours, palette
#'
#' @rdname dot-int_getColSubset
#'
.int_getColSubset <- function(no1, no2) {
  colours <- getColours(no1 + no2)
  out <- colours[no2:length(colours)]

  return(out)
}

#' Get Subclusters from Heatmap
#'
#' Assigns subclusters to barcodes based on the input heatmap and the specified
#' number of clusters.
#'
#' @param heatmap Data containing clustering information.
#' @param k Number of subclusters.
#'
#' @return A data frame with barcode and corresponding subcluster assignment.
#'
.int_getSubClusts <- function(heatmap, k) {
  # Get the subclusters
  subclusts <- stats::cutree(heatmap$tree_col, k = k) %>%
    .[heatmap$tree_col$order] %>%
    as.data.frame() %>%
    dplyr::rename("subclust" = ".") %>%
    tibble::rownames_to_column(var = "Barcode")

  return(subclusts)
}


#' Internal: Extract and Process Mapping Value
#'
#' This function extracts the value associated with a specified variable name
#' from a mapping and performs various string processing operations on the
#' extracted value.
#'
#' @param mapping A named list or vector representing the mapping.
#' @param varname The name or index of the variable to extract from the
#'                mapping.
#'
#' @return The processed value associated with the specified variable name. If
#' the processed value contains comma-separated elements, it is returned as a
#' vector of strings. Otherwise, it is returned as a single string.
#'
#' @details
#' The function performs the following steps:
#' 1. Extracts the value associated with the specified variable name from the
#' mapping.
#' 2. If the version of the 'ggplot2' package is greater than "2.2.1", it
#'    removes all occurrences of the tilde character (~) from the extracted
#'    value.
#' 3. Removes all occurrences of "c(", ")", and white space characters from the
#'    extracted value using a regular expression.
#' 4. If the processed value contains a comma, it splits the value into a
#'    vector of strings using the comma as the separator.
#' 5. Returns the processed value.
#'
#' @importFrom utils packageVersion
#'
#' @rdname dot-int_getMapping
#'
.int_getMapping <- function(mapping, varname) {
  result <- mapping[varname]
  if (packageVersion("ggplot2") > "2.2.1") {
    result <- gsub("~", "", result, fixed = TRUE)
  }
  result <- gsub("c\\(|\\)|\\s", "", result, perl = TRUE)
  if (grepl(",", result, fixed = TRUE)) {
    result <- strsplit(result, ",", fixed = TRUE)[[1]]
  }
  result
}


#' Internal: Check the validity of mapping inputs for pie and donut plots
#'
#' This function checks if the provided mapping inputs for the pie and donut
#' plots are valid. It ensures that the mapping names are among the allowed
#' options, which are 'annotation', 'cluster', and 'factors'.
#'
#' @param mapping A ggplot2 `aes` function output containing the mapping
#' information for the pie and donut plots. The names should be 'pie' and
#' 'donut', and the values should be the column names from the colData.
#'
#' @return If the mappings are valid, the function returns `NULL` invisibly.
#' If the mappings are invalid, the function throws an error with a
#' descriptive message.
#'
#' @keywords internal
#'
#' @rdname dot-int_checkMappings
#' @author Eleftherios (Lefteris) Zormpas
.int_checkMappings <- function(mapping) {
  ## Extract mapping names
  pies <- .int_getMapping(mapping, "pie")
  donuts <- .int_getMapping(mapping, "donut")

  ## Define the allowed mappings
  allowed_mappings <- c("annotation", "cluster", "factors")

  ## Check if pie mappings are valid
  if (!(pies %in% allowed_mappings)) {
    stop("Currently, only 'annotation', 'cluster', and 'factors' are ",
         "available for 'pie' mappings. If there is a need for other columns ",
         "from the colData, please file a GitHub issue.")
  }

  ## Check if donut mappings are valid
  if (!(donuts %in% allowed_mappings)) {
    stop("Currently, only 'annotation', 'cluster', and 'factors' are ",
         "available for 'pie' mappings. If there is a need for other columns ",
         "from the colData, please file a GitHub issue.")
  }

  ## If no errors, the mappings are valid
  invisible(NULL)
}


#' Internal: Prepare data for the pie-doughnut chart
#'
#' This function prepares data for the pie-doughnut chart
#'
#' @param fgwc an object of class `fgwc`
#' @param sfe an object of class `SpatialFeatureExperiment`
#' @param pies pie mapping
#' @param donut donut mapping
#'
#' @returns A data frame.
#' @author Eleftherios (Lefteris) Zormpas
#' @rdname dot-int_getPieDonutData
#'
.int_getPieDonutData <- function(fgwc, sfe, pies, donuts) {
  fgwc_finalData <- fgwc$finaldata %>%
    rownames_to_column(var = "Barcode")

  annot <- colData(sfe)["annotation"] %>%
    as.data.frame() %>%
    rownames_to_column(var = "Barcode")

  data <- left_join(fgwc_finalData, annot, by = "Barcode")

  if ("factors" %in% c(pies, donuts)) {
    data <- tidyr::pivot_longer(data,
                                contains("Factor"),
                                names_to = "factors",
                                values_to = "factor_score") %>%
      group_by(Barcode) %>%
      dplyr::slice_max(order_by = factor_score) %>%
      dplyr::ungroup() %>%
      dplyr::select(-tidyr::all_of(c("factor_score", "Barcode")))
  }

  data <- data %>%
    dplyr::select(tidyr::all_of(c(pies, donuts)))
}

#' Internal: Check if an Object is of Class 'fgwc'
#'
#' This function checks if a given object is of class 'fgwc'.
#'
#' @param object The object to check.
#' @returns A logical value indicating whether the object is of class 'fgwc'.
#' @author Eleftherios (Lefteris) Zormpas
#' @rdname dot-int_checkFGWCClass
#'
.int_checkFGWCClass <- function(object) {
  if (!inherits(object, "fgwc")) {
    stop("The `fgwc` argument must an object of class `fgwc` as generated by ",
         "the `fgwc_STE` function.")
  }
}


#' Internal: Extract Factor Data
#'
#' This function extracts factor data from FGWC output
#'
#' @param fgwc fgwc class object as generated by `fgwcSTE`
#'
#' @returns a data frame of NMF factors
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @rdname dot-int_getFactorData
#'
.int_getFactorData <- function(fgwc) {
  fgwc$finaldata %>%
    dplyr::select(contains("Factor"))
}


#' Internal: Get Annotations and Colours
#'
#' This function returns annotations label and colours for the heatmap
#'
#' @param fgwc gwc class object as generated by `fgwcSTE`
#' @param loc-annot which annotations to add
#' @param order_rows order rows based on annotation or cluster
#'
#' @returns a list
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @rdname dot-int_getAnnotsAndColours
#'
.int_getAnnotsAndColours <- function(fgwc, loc_annot, order_rows) {
  annotations <- fgwc$finaldata %>%
    dplyr::select(dplyr::any_of(c("cluster", "annotation"))) %>%
    dplyr::mutate(cluster = as.factor(cluster))

  col_clust <- length(unique(annotations$cluster))
  annot_colours <- list(cluster = getColours(col_clust))
  names(annot_colours$cluster) <- unique(annotations$cluster)

  if ("annotation" %in% colnames(annotations)) {
    col_annot <- length(unique(annotations$annotation))
    annot_colours[["annotation"]] <- c4a(palette = "carto.pastel", n = col_annot)
    names(annot_colours$annotation) <- unique(annotations$annotation)
  }

  if (loc_annot %in% c("cluster", "annotation")) {
    annotations <- annotations %>%
      dplyr::select(all_of(loc_annot))
    annot_colours <- annot_colours[[loc_annot]]
  }

  if (order_rows %in% c("cluster", "annotation")) {
    annotations <- annotations %>%
      dplyr::arrange(.data[[order_rows]])
  }

  list(annotations = annotations, colours = annot_colours)
}


#' Internal: Extract Metagene Data
#'
#' This function extracts metagene data from FGWC output
#'
#' @param fgwc fgwc class object as generated by `fgwcSTE`
#'
#' @returns a data frame of NMF factors
#'
#' @importFrom dplyr rename_with
#'
#' @author Eleftherios (Lefteris) Zormpas
#' @rdname dot-int_getMetageneData
#'
.int_getMetageneData <- function(fgwc) {
  n <- ncol(fgwc$metageneSignatures)
  fgwc$metageneSignatures %>%
    dplyr::rename_with(~ paste0("Factor", sapply(1:n, .int_addLeadingZero)))
}



