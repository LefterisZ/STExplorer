#' Plot global PCA results
#'
#' @name plotGWPCA_global
#' @description
#' A function to plot the global PCA results as generated by \code{gwpca.ste}.
#' Has to options, 'scree' and 'scatter'. The first will plot a scree plot of
#' the percentage of total variation of a selection of principal components. The
#' latter will produce a scatter plot of the two selected components.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste}.
#' @param comps the components to be plotted. If type == scree, it is a numeric
#' vector. If type == scatter, it is a numeric vector of length 2
#' (i.e., comps 1:2 will plot the two first components).
#' @param type either 'scree' or 'scatter'.
#' @param point_args arguments to pass to \code{geom_point()} when you don't
#' want them to be shared with \code{geom_line()}.
#' @param line_args arguments to pass to \code{geom_line()} when you don't
#' want them to be shared with \code{geom_point()}.
#' @param ... arguments to be passed to both \code{geom_point()} and
#' \code{geom_line()}.
#'
#' @returns A ggplot object.
#'
#' @importFrom ggplot2 geom_point geom_line ggplot labs theme ylim
#' @importFrom ggplot2 theme_classic aes
#' @importFrom methods is
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @details
#' This function plots the results of a global principal component analysis. It
#' can generate two types of plots: a scree plot and a scatter plot.
#'
#' - The scree plot (type = "scree") shows the percentage of variation explained
#' by each component. It helps in determining the optimal number of components
#' to retain.
#'
#' - The scatter plot (type = "scatter") shows the scores of two components on
#' a two-dimensional plot. It requires running the gwpcaSTE function with the
#' scores argument set to TRUE to calculate the scores.
#'
#' The comps argument specifies the components to include in the plot. By
#' default, it includes the first 10 components. The point_args and line_args
#' arguments allow for customization of the appearance of the points and lines
#' in the plot, respectively.
#'
#' @examples
#' # Load gwpca data
#' data(gwpca)
#'
#' # Plot scree plot of PCA results
#' plotGWPCA_global(gwpca, type = "scree")
#'
#' # Plot scatter plot of PCA results for components 1 and 2
#' \dontrun{
#' plotGWPCA_global(gwpca, type = "scatter", comps = c(1, 2))
#' }
#' # Customize the appearance of points in the scatter plot
#' \dontrun{
#' plotGWPCA_global(gwpca, type = "scatter",
#' point_args = list(size = 3, color = "red"))
#' }
#' @export
plotGWPCA_global <- function(gwpca,
                             comps = 1:10,
                             type = c("scree", "scatter"),
                             point_args = list(),
                             line_args = list(),
                             ...) {
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(is.list(point_args))
    stopifnot(is.list(line_args))

    ## Check valid type argument
    type <- match.arg(type)

    ## Prepare data
    if (type == "scree") {
        ## Calculate percent of variation explained
        pvar <- (gwpca$pca$sdev^2/sum(gwpca$pca$sdev^2))*100
        pvar <- data.frame(var = pvar,
                           PCs = sprintf("PC%03d", seq_along(pvar)))
    } else if (type == "scatter") {
        ## Extract scores for two components
        scores <- gwpca$pca$scores[, comps]
        if (is.null(scores)) {
            cat("To be able to plot a scatter plot of PCs you need to run the",
                "`gwpcaSTE` function with the `scores` argument set to TRUE.\n")
            stop()
        }
        df <- data.frame(scores[, comps[1]], scores[, comps[2]])
        colnames(df) <- sprintf("PC%d", seq_along(colnames(scores)))
    }

    ## Plot types for global PCA results
    plot_types <- list(
        scree = function(point_args, line_args, ...) {
            ggplot(pvar[comps,], aes(x = PCs, y = var, group = 1)) +
                do.call(geom_line, c(list(...), line_args)) +
                do.call(geom_point, c(list(...), point_args)) +
                labs(x = "Principal Component",
                     y = "% Variance Explained",
                     title = "Scree Plot") +
                ylim(0, 100) +
                theme_classic()
        },
        scatter = function(point_args, ...) {
            ggplot(df, aes(x = df[,1], y = df[,2])) +
                do.call(geom_point, c(list(...), point_args)) +
                labs(x = paste0("Principal Component ", comps[1]),
                     y = paste0("Principal Component ", comps[2]),
                     title = paste0("PCA Plot of ", colnames(df)[1],
                                    " vs ", colnames(df)[2])) +
                theme_classic()
        }
    )

    ## Plot
    plot_fun <- plot_types[[type]]

    if (is.null(plot_fun)) {
        stop("Invalid type argument. Valid options are 'scree' and 'scatter'.")
    }

    ## Call plot function with arguments
    plot <- do.call(plot_fun,
                    c(list(point_args = point_args, line_args = line_args),
                      ...))

    ## Return plot
    return(plot)
}

#' Plot Leading Genes or Leading Gene Groups in GWPCA
#'
#' @name plotGWPCA_leadingG
#' @description
#' A function to map the leading genes or leading gene groups per location.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param arrange to indicate whether to arrange the plots in a panel or not.
#' The default is set to FALSE.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the
#' aesthetic.
#'
#' @returns Returns a list of plots; one per Principal Component. If arrange ==
#' TRUE then a 2x2 panel is plotted too. If more than 4 PCs are provided in the
#' \code{comps} argument then only a list of plots is returned.
#'
#' @importFrom ggplot2 ggplot labs theme geom_sf aes
#' @importFrom ggplot2 theme_void scale_fill_manual
#' @importFrom gridExtra grid.arrange
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @details
#' This function plots the leading genes or gene groups in a global weighted
#' principal component analysis (GWPCA). It can generate two types of plots:
#' individual plots for leading genes (type = "single") or a single plot for
#' gene groups (type = "multi").
#'
#' For type = "single", the function plots the leading genes individually. The
#' comps argument specifies the components for which to plot the leading genes.
#' The leading genes are represented as spatial polygons on a plot, where each
#' gene is coloured based on its score for the corresponding component. The ...
#' argument allows for customizing the appearance of the plots using additional
#' arguments passed to the geom_sf function.
#'
#' For type = "multi", the function plots the gene groups. The comps argument
#' specifies the components for which to plot the gene groups. The gene groups
#' are represented as spatial polygons on a single plot, where each group is
#' coloured based on the scores of the leading genes in that group. The ...
#' argument allows for customizing the appearance of the plot using additional
#' arguments passed to the geom_sf function.
#'
#' The arrange argument, when set to TRUE, arranges the individual plots in a
#' grid layout when the number of components specified is less than or equal to
#' 4. By default, the individual plots are returned as a list. If arrange is
#' TRUE and the number of components is greater than 4, a message is displayed,
#' and the individual plots are returned as a list.
#'
#' @examples
#' # Load gwpca data
#' data(gwpca)
#'
#' # Plot individual leading genes for components 1 and 2
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2), type = "single")
#'
#' # Plot gene groups for components 1 and 2
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2), type = "multi")
#'
#' # Arrange individual plots in a grid layout
#' plotGWPCA_leadingG(gwpca, comps = c(1, 2, 3, 4),
#' type = "single", arrange = TRUE)
#'
#' @export
plotGWPCA_leadingG <- function(gwpca,
                               comps,
                               type = c("single", "multi"),
                               arrange = FALSE,
                               ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "single") {
        lead.item <- gwpca$leadingGeneSingle
        legend <- "right"
        title <- "Genes"
    } else if (type == "multi") {
        lead.item <- gwpca$leadingGeneMulti
        legend <- "none"
        title <- "Genes Groups"
    }

    ## Define a function to generate the plot for a given component
    generate_plot <- function(pc.No) {
        col.No <- length(unique(lead.item[, pc.No]))
        colour.values <- getColours(col.No)

        ggplot() +
            geom_sf(aes(geometry = lead.item$geometry$geometry,
                        fill = lead.item[, pc.No]), ...) +
            scale_fill_manual(values = colour.values) +
            labs(title = paste0("Leading ", title, " on PC", pc.No),
                 fill = "Leading Genes") +
            theme_void() +
            theme(legend.position = legend)
    }

    ## Create a list of plots for each component using lapply
    plots <- lapply(comps, generate_plot)

    ## Check if arrange is TRUE and comps length is less than or equal to 4
    if (arrange && length(comps) <= 4) {
        n <- length(comps)
        nrow <- if (n %in% c(1, 2)) 1 else 2
        ncol <- if (n == 3) 2 else 2
        do.call(gridExtra::grid.arrange, c(plots, nrow = nrow, ncol = ncol))
        message("Plots arranged in a ", nrow, "x", ncol, " panel.")
    } else if (length(comps) > 4) {
        message("More than 4 components specified.
    Returning a list of individual plots.")
    }

    ## Return the list of plots
    return(plots)
}

#' Plot violins and map for Percent of Total Variation.
#'
#' @name plotGWPCA_ptv
#' @description
#' A function to plot and map the Percent of Total Variation (PTV) of the local
#' Principal Components for each location.
#'
#' @param gwpca a list of class \code{gwpca}, generated by \code{gwpca.ste} and
#' updated with leading genes by \code{gwpca.LeadingGene}.
#' @param comps the components to be plotted. The maximum is based on the max
#' number of components used in the \code{gwpca.propVar} function. If one
#' component is provided here, then only one violin plot or map will be plotted.
#' If it is a numeric vector then the corresponding plots will be plotted.
#' @param type either 'single' for single leading gene per location or 'multi'
#' for k leading genes per location.
#' @param violin_args a list of arguments to be passed to \code{geom_violin()}
#' for customizing the violin plots. Defaults to an empty list.
#' @param box_args a list of arguments to be passed to \code{geom_boxplot()} for
#' customizing the boxplots. Defaults to an empty list.
#' @param fill_args a list of arguments to be passed to
#' \code{scale_fill_manual()} for customizing the fill colors of the plots.
#' Defaults to an empty list.
#' @param lab_args a list of arguments to be passed to \code{labs()} for
#' customizing the plot labels. Defaults to an empty list.
#' @param ... arguments to be passed to both \code{geom_sf()} outside of the
#' aesthetic.
#'
#' @importFrom gridExtra grid.arrange
#' @importFrom reshape2 melt
#' @importFrom ggplot2 geom_boxplot geom_sf geom_violin ggplot labs theme
#' @importFrom ggplot2 theme_classic theme_void facet_wrap aes
#' @importFrom ggplot2 scale_fill_viridis_c scale_fill_manual
#' @importFrom magrittr %>%
#' @importFrom dplyr n_distinct all_of
#'
#' @details
#' The comps argument is passed down to select the aggregates of components to
#' be plotted. Remember that PTVs are cumulative. This means that Comps_01
#' inside \code{gwpca$ptvs} shows the PTV for PC 1 per location. Next, Comps_02
#' shows the cumulative PTV for PCs 1 and 2 per location etc. As a result, when
#' you give `comps` = c(1, 5) then the violin plots for the cumulative PTV of
#' the first and the first 5 PCs per location will be plotted or mapped. If you
#' provide a single number then a single violin plot or map will be plotted. If
#' you provide a vector of numbers then a plot with multiple violins (arrange =
#' TRUE), or multiple single violins, or a panel of maps will be plotted, or
#' multiple single maps.
#'
#' @returns Returns a ggplot object.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load required packages
#' library(ggplot2)
#'
#' # Load data
#' data(gwpca)
#' data(sfe)
#'
#' # Add PTV data
#' gwpca <- gwpca_PropVar(gwpca = gwpca, n_comp = 2:10, sfe = sfe)
#'
#' # Plot PTV as violin plot
#' plotGWPCA_ptv(gwpca, comps = 1:5, type = "violin")
#'
#' # Plot PTV as map
#' plotGWPCA_ptv(gwpca, comps = 1:5, type = "map")
#'
#' @export
plotGWPCA_ptv <- function(gwpca,
                          comps,
                          type = c("violin", "map"),
                          violin_args = list(),
                          box_args = list(),
                          fill_args = list(),
                          lab_args = list(),
                          ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(is.numeric(comps))
    stopifnot(!is.null(gwpca$ptvs))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "violin") {
        ptvs <- gwpca$ptvs[,!(colnames(gwpca$ptvs) %in% "geometry")] %>%
            .[, comps] %>%
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        col_ns <- colnames(gwpca$ptvs)[comps]
        ptvs <- gwpca$ptvs %>%
            select(all_of(c(col_ns, "geometry"))) %>%
            reshape2::melt(data = ., measure.vars = col_ns)
    }

    ## Set some defaults if not provided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1,
                         fill = "grey40",
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = getColours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }

    ## Set some defaults if not priovided
    if (isEmpty(violin_args) & type == "violin") {
        violin_args <- list(alpha = 0.8,
                            trim = FALSE)
    }
    if (isEmpty(box_args) & type == "violin") {
        box_args <- list(width = 0.1,
                         fill = "grey40",
                         outlier.colour = NA)
    }
    if (isEmpty(fill_args)) {
        fill_args <- list(values = getColours(length(comps)))
    }
    if (isEmpty(lab_args) & type == "violin") {
        labs_args <- list(title = "Local PCs PTV",
                          x = "",
                          y = "Percentage of Total Variation (PTV)",
                          fill = "No. of PCs")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Percantage of Total Variation\n(PTV)")
    }

    ## List of plots
    plot_list <- list(
        violin = function(violin_args, box_args, labs_args, fill_args, ...){
            ggplot(ptvs, aes(x = variable, y = value, fill = variable)) +
                do.call(geom_violin, c(list(...), violin_args)) +
                do.call(scale_fill_manual, c(fill_args)) +
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(labs, labs_args) +
                ylim(0, 100) +
                theme_classic()
        },
        map = function(comps, labs_args, ...){
            ggplot(data = ptvs) +
                geom_sf(aes(geometry = geometry, fill = value), ...) +
                scale_fill_viridis_c(option = "magma", limits = c(0, 100)) +
                facet_wrap(~variable, ncol = ceiling(sqrt(n_distinct(comps)))) +
                do.call(labs, labs_args) +
                theme_void() +
                theme(legend.position = "right")
        }
    )

    ## Get the required plot function
    plot_fun <- plot_list[[type]]

    ## Fetch appropriate arguments
    if (type == "violin") {
        args_list <- list(violin_args = violin_args,
                          box_args = box_args,
                          labs_args = labs_args,
                          fill_args = fill_args)
    } else if (type == "map") {
        args_list <- list(comps = comps,
                          labs_args = labs_args)
    }

    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun,
                    c(list(...), args_list))

    return(plot)
}


#' Visualise outliers in box-plot or map
#'
#' @name plotGWPCA_discr
#'
#'
#' @description
#' This function plots discrepancies using either a boxplot or a map. It
#' visualizes the discrepancies in the local Principal Components (PCs) for each
#' location based on the coefficient of variation (CV).
#'
#' @param gwpca A list of class `gwpca` containing the necessary data.
#' @param type Specifies the type of plot to generate. Can be either "box" for
#' a boxplot or "map" for a map. Default is "box".
#' @param box_args Additional arguments to customize the appearance of the
#' boxplot.
#' @param jitt_args Additional arguments to customize the appearance of the
#' jitter points in the boxplot.
#' @param hline_args Additional arguments to customize the appearance of the
#' horizontal line in the boxplot.
#' @param lab_args Additional arguments to customize the labels of the plot.
#' @param ... Additional arguments to be passed to the `geom_boxplot()` or
#' `geom_sf()` functions.
#'
#' @details
#' # Dependencies
#' The function depends on the `ggplot2` and `sf` packages.
#'
#' The function first checks the validity of the input arguments. It then
#' fetches the necessary data from the `gwpca` object and calculates the
#' outliers using the `outlier_cutoff()` function. Depending on the `type`
#' specified, the data is prepared accordingly for either a boxplot or a map.
#'
#' For the boxplot, the discrepancies (`cvs`) are reshaped into a data frame and
#' plotted using `geom_boxplot()`. Jitter points can also be added using
#' `geom_jitter()`. A horizontal line is drawn at the upper outlier threshold.
#' Customization of the plot appearance is possible through the provided
#' arguments.
#'
#' For the map, the discrepancies, along with the geometry information, are
#' combined into a data frame. The map is then created using `geom_sf()`, with
#' the discrepancies represented by fill color. Outliers are also marked with a
#' transparent fill color and a black border. Customization options for the map
#' appearance are available through the arguments.
#'
#' @importFrom ggplot2 aes coord_flip element_blank facet_wrap geom_boxplot
#' @importFrom ggplot2 geom_hline geom_jitter geom_sf ggplot labs  theme
#' @importFrom ggplot2 scale_fill_viridis_c theme_classic theme_void
#' @importFrom dplyr mutate if_else
#' @importFrom reshape2 melt
#' @importFrom scales alpha
#' @importFrom magrittr %>%
#' @importFrom S4Vectors isEmpty
#'
#' @returns The function returns the created plot.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load data
#' data(gwpca)
#'
#' # Plot discrepancies as a boxplot
#' plotGWPCA_discr(gwpca, type = "box")
#'
#' # Plot discrepancies as a map
#' plotGWPCA_discr(gwpca, type = "map")
#'
#' @export
plotGWPCA_discr <- function(gwpca,
                            type = c("box", "map"),
                            box_args = list(),
                            jitt_args = list(),
                            hline_args = list(),
                            lab_args = list(),
                            ...){
    ## Checks arguments
    stopifnot(is(gwpca, "gwpca"))
    stopifnot(!is.null(gwpca$geometry))
    stopifnot(!is.null(gwpca$CV))

    ## Check valid type argument
    type <- match.arg(type)

    ## Fetch the data
    if (type == "box") {
        discs <- data.frame(cvs = gwpca$CV$CV) %>%
            reshape2::melt(data = ., measure.vars = colnames(.))
    } else if (type == "map") {
        discs <- data.frame(cvs = gwpca$CV$CV,
                            is_disc = gwpca$CV$is_outlier,
                            geometry = gwpca$geometry) %>%
            mutate(out_geom = geometry,
                   out_geom = if_else(is_disc == FALSE, NA, out_geom))
    }

    ## Set some defaults if not provided
    if (isEmpty(box_args) & type == "box") {
        box_args <- list(width = 0.8,
                         fill = "#D1E5F0",
                         colour = "#2166AC",
                         outlier.colour = "red",
                         outlier.size = 2)
    }
    if (isEmpty(jitt_args) & type == "box") {
        jitt_args <- list(col = "#EF8A62",
                          size = 2,
                          width = 0.3,
                          alpha = 0.8)
    }
    if (isEmpty(hline_args) & type == "box") {
        hline_args <- list(yintercept = gwpca$CV$out_up,
                           linetype = "dashed",
                           color = "royalblue")
    }
    if (isEmpty(lab_args) & type == "box") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          x = "",
                          y = "Discrepancy score")
    } else if (isEmpty(lab_args) & type == "map") {
        labs_args <- list(title = "Local PCs Discrepancy",
                          fill = "Discrepancy\nscore")
    }

    ## List of plots
    plot_list <- list(
        box = function(box_args, jitt_args, hline_args, labs_args, ...){
            ggplot(discs, aes(x = variable, y = value)) +
                do.call(geom_boxplot, c(list(...), box_args)) +
                do.call(geom_jitter, c(list(...), jitt_args)) +
                do.call(geom_hline, c(list(...), hline_args)) +
                do.call(labs, labs_args) +
                coord_flip() +
                theme_classic() +
                theme(axis.text.y = element_blank(),
                      axis.ticks.y = element_blank())
        },
        map = function(labs_args, ...){
            ggplot(data = discs) +
                geom_sf(aes(geometry = geometry, fill = cvs),
                        colour = NA, ...) +
                geom_sf(aes(geometry = out_geom),
                        fill = alpha("white", 0),
                        colour = "black",
                        linewidth = 0.5) +
                scale_fill_viridis_c(option = "inferno",) +
                do.call(labs, labs_args) +
                theme_void() +
                theme(legend.position = "right")
        }
    )

    ## Get the required plot function
    plot_fun <- plot_list[[type]]

    ## Fetch appropriate arguments
    if (type == "box") {
        args_list <- list(box_args = box_args,
                          jitt_args = jitt_args,
                          hline_args = hline_args,
                          labs_args = labs_args)
    } else if (type == "map") {
        args_list <- list(labs_args = labs_args)
    }

    ## Call plot function with appropriate arguments
    plot <- do.call(plot_fun,
                    c(list(...), args_list))

    return(plot)

}


#' Plot GWPCA Discrepancy Heatmap
#'
#' Generates a discrepancy heatmap based on GWPCA results for specific tissue
#' locations.
#' @name plotGWPCA_discrHeatmap
#'
#' @param sfe SpatialFeatureExperiment object.
#' @param assay Assay type for the spatial expression data (counts, logcounts
#' etc.).
#' @param vars Variables of interest (genes) to be evaluated. Default is NULL,
#' which includes all variables.
#' @param focus Tissue locations of interest (barcodes) for which discrepancy
#' heatmaps will be generated.
#' @param dMetric Distance metric used for generating the distance matrix which
#' will be used to identify the focus location's neighbours.
#' @param sample_id Sample ID for which discrepancy data is retrieved.
#' @param bw Bandwidth parameter for selecting neighbours for the heatmap.
#' @param mean.diff Threshold for selecting genes based on the difference from
#' the mean discrepancy score.
#' @param show.vars Display option for variables (genes) in the heatmap. Options
#' are "top" (genes with higher discrepancies) or "all" (all genes).
#' @param scale Scaling method for the heatmap. Options are "row" (row scaling)
#' or "none" (no scaling).
#' @param gene.names Logical indicating whether to display gene names instead of
#' ENSGene IDs.
#' @param ... Additional arguments to be passed to the pheatmap function.
#'
#' @details This function generates discrepancy heatmaps based on GWPCA results
#' for specific tissue locations (focus). It retrieves the discrepancy data
#' using the `gwpca_Discrepancy` function, annotates the columns with distance
#' information, generates annotation colors based on distance levels, and plots
#' the heatmap using the `pheatmap` function.
#'
#' @importFrom pheatmap pheatmap
#' @importFrom dplyr select starts_with left_join mutate if_else ends_with
#' @importFrom tibble rownames_to_column column_to_rownames
#' @importFrom scales grey_pal
#' @importFrom magrittr %>%
#'
#' @returns plots a heatmap.
#'
#' @author Eleftherios (Lefteris) Zormpas
#'
#' @examples
#' # Load data
#' data(sfe)
#'
#' # Set parameters
#' assay <- "logcounts"
#' focus <- colnames(sfe)[1] # outlier Barcode
#' sample_id <- "JBO019"
#' dMetric <- "euclidean"
#' bw <- 450
#' show.vars <- "top"
#'
#' # Plot
#' plotGWPCA_discrHeatmap(sfe, assay = assay,
#' focus = focus,
#' dMetric = dMetric, sample_id = sample_id,
#' bw = bw, mean.diff = 1, show.vars = show.vars, scale = "row",
#' gene.names = TRUE)
#'
#' @export
plotGWPCA_discrHeatmap <- function(sfe,
                                   assay,
                                   vars = NULL,
                                   focus,
                                   dMetric,
                                   sample_id,
                                   bw,
                                   mean.diff = 1,
                                   show.vars = c("top", "all"),
                                   scale = "row",
                                   gene.names = FALSE,
                                   ...) {
    for (i in focus) {
        ## Get the discrepancy data
        dt.focus.list <- getDiscrepancyGeneData(sfe = sfe,
                                                assay = assay,
                                                vars = vars,
                                                focus = i,
                                                dMetric = dMetric,
                                                sample_id = sample_id,
                                                bw = bw,
                                                mean.diff = mean.diff,
                                                exportExpression = FALSE)
        data.focus <- dt.focus.list$data.focus

        ## Annotate the columns with distance information
        nbr.annotation <- data.focus %>%
            dplyr::select(Distance)

        ## Generate annotation colors based on distance levels
        nbr.lvls <- with(nbr.annotation, table(Distance))
        nbr.ann.colours <- scales::grey_pal(start = 0, end = 0.8)(length(nbr.lvls))
        nbr.ann.colours[1] <- "red" # Make the focus point red
        nbr.ann.colours <- rep(nbr.ann.colours, times = nbr.lvls)
        nbr.ann.colours <- list(Distance = nbr.ann.colours)

        ## Drop distance
        data.focus <- data.focus %>%
            dplyr::select(starts_with("ENSG")) %>%
            t() %>%
            as.data.frame()

        ## Translate the ENSGene IDs to Gene names
        if (gene.names) {
            data.focus <- data.focus  %>%
                rownames_to_column(var = "id") %>%
                left_join(dt.focus.list$annot) %>%
                mutate(gene_name = if_else(is.na(gene_name), id, gene_name)) %>%
                column_to_rownames(var = "gene_name") %>%
                select(ends_with("-1"))
        }

        ## Plot the heatmap
        pheatmap(data.focus,
                 scale = scale,
                 annotation_col = nbr.annotation,
                 annotation_colors = nbr.ann.colours,
                 ...)
    }
}

