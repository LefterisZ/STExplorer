% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gwr_STE.R
\name{gwrSTE}
\alias{gwrSTE}
\title{Geographically Weighted Regression (GWR)}
\usage{
gwrSTE(
  gwr_method = c("basic", "gtwr", "gwr-lcr", "gwr-generalised"),
  formula,
  m_sfe,
  sample_id,
  bw,
  kernel = c("bisquare", "gaussian", "exponential", "tricube", "boxcar"),
  assay = "logcounts",
  adaptive = FALSE,
  p = 2,
  dMat = NULL,
  F123.test = FALSE,
  cv = TRUE,
  W.vect = NULL,
  parallel.method = FALSE,
  parallel.arg = NULL,
  lamda = 0.05,
  t.units = "auto",
  ksi = 0,
  st.dMat = NULL,
  obs.tv = NULL,
  lambda_lcr = 0,
  lambda.adjust = FALSE,
  cn.thresh = NA,
  scale = TRUE
)
}
\arguments{
\item{gwr_method}{Character vector specifying the GWR method to use. Possible
values are: "basic" for basic GWR, "gtwr" for Geographically and Temporally
Weighted Regression, "gwr-lcr" for Locally Compensated Ridge GWR (GWR-LCR),
and "gwr-generalised" for Generalised GWR modeÎ».}

\item{formula}{Regression model formula of a \code{\link{formula}} object.}

\item{m_sfe}{An object of class SpatialFeatureExperiment or
MetaSpatialFeatureExperiment.}

\item{sample_id}{Character string, TRUE, or NULL specifying sample/image
identifier(s); here, TRUE is equivalent to all samples/images.}

\item{bw}{Bandwidth for the GWR.}

\item{kernel}{Function chosen as follows:
\itemize{
\item{gaussian}{wgt = exp(-.5*(vdist/bw)^2);}
\item{exponential}{wgt = exp(-vdist/bw);}
\item{bisquare}{wgt = (1-(vdist/bw)^2)^2 if vdist < bw,
wgt=0 otherwise;}
\item{tricube}{wgt = (1-(vdist/bw)^3)^3 if vdist < bw,
wgt=0 otherwise;}
\item{boxcar}{wgt=1 if dist < bw, wgt=0 otherwise.}
}}

\item{assay}{The counts assay to use. Defaults to "logcounts".}

\item{adaptive}{If \code{TRUE}, calculate an adaptive kernel where the
bandwidth (\code{bw}) corresponds to the number of nearest neighbours
(i.e., adaptive distance); default is \code{FALSE}, where a fixed kernel
is found (bandwidth is a fixed distance).}

\item{p}{The power of the Minkowski distance, default is 2, i.e., the
Euclidean distance.}

\item{dMat}{A pre-specified distance matrix, it can be calculated and added
to the SFE object by the \code{\link{addDistMat}} function. If \code{NULL}, it
fetches the first (or only) distance matrix from the SFE's metadata slot.
If you have multiple distance matrices then you can use one of the
\code{"euclidean"}, \code{"manhattan"}, or \code{"minkowski"} to select the one you
prefer. Defaults to \code{NULL}. If you want to calculate a different distance
matrix, you can do so by using the \code{\link[GWmodel]{gw.dist}} function.
Then, provide the matrix as a value to this argument.}

\item{F123.test}{If TRUE, conduct three separate F-tests according to
Leung et al. (2000).}

\item{cv}{If TRUE, cross-validation data will be calculated and returned in
the output Spatial*DataFrame.}

\item{W.vect}{Default NULL, if given it will be used to weight the distance
weighting matrix.}

\item{parallel.method}{FALSE as default, and the calibration will be
conducted traditionally via the serial technique, "omp": multi-thread
technique with the OpenMP API, "cluster": multi-process technique with
the \pkg{parallel} package, "cuda": parallel computing technique with CUDA.}

\item{parallel.arg}{If \code{parallel.method} is not FALSE, then set the
argument as follows: if \code{parallel.method} is "omp",
\code{parallel.arg} refers to the number of threads used, and its default
value is the number of cores - 1; if \code{parallel.method} is "cluster",
\code{parallel.arg} refers to the number of R sessions used, and its
default value is the number of cores - 1; if \code{parallel.method} is
"cuda", \code{parallel.arg} refers to the number of calibrations included
in each group, but note a too large value may cause the overflow of GPU
memory.}

\item{lamda}{A parameter between 0 and 1 for calculating spatio-temporal
distance. Used only for the \code{gwr_method}: \code{"gtwr"}.}

\item{t.units}{Character string to define time unit. Used only for the
\code{gwr_method}: \code{"gtwr"}.}

\item{ksi}{A parameter between 0 and PI for calculating spatio-temporal
distance, see details in Wu et al. (2014). Used only for the
\code{gwr_method}: \code{"gtwr"}.}

\item{st.dMat}{A pre-specified spatio-temporal distance matrix. Used only
for the \code{gwr_method}: \code{"gtwr"}.}

\item{obs.tv}{A vector of time tags for each observation, which could be
numeric or of POSIXlt class. Used only for the \code{gwr_method}: \code{"gtwr"}.}

\item{lambda_lcr}{Option for a globally-defined (constant) ridge parameter.
Default is lambda=0, which gives a basic GWR fit. Used only for
the \code{gwr_method}: \code{"gwr-lcr"}.}

\item{lambda.adjust}{A locally-varying ridge parameter. Default FALSE,
refers to: (i) a basic GWR without a local ridge adjustment (i.e. lambda=0,
everywhere); or (ii) a penalised GWR with a global ridge adjustment (i.e.
lambda is user-specified as some constant, other than 0 everywhere); if
TRUE, use cn.tresh to set the maximum condition number. For locations with
a condition number (for its local design matrix), above this
user-specified threshold, a local ridge parameter is found.}

\item{cn.thresh}{Maximum value for condition number, commonly set between
20 and 30.}
}
\value{
Returns the GWR model object.
}
\description{
A function to perform Geographically Weighted Regression (GWR) using different
methods specified by the user.
}
\examples{
\dontrun{
# Example usage:
gwrSTE(gwr_method = "basic",
       formula = Y ~ X1 + X2,
       m_sfe = sfe_object,
       sample_id = TRUE,
       bw = 100,
       kernel = "gaussian",
       adaptive = FALSE,
       p = 2,
       F123.test = FALSE,
       cv = TRUE)
}
}
\author{
Eleftherios Zormpas
}
